<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko_KR"><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://jamesu.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jamesu.dev/" rel="alternate" type="text/html" hreflang="ko_KR" /><updated>2020-06-01T01:05:12+09:00</updated><id>https://jamesu.dev/</id><title type="html">Jamesu Devlog</title><subtitle>Dev Blog by James Minsu Jeon</subtitle><author><name>jamesujeon</name><email>jamesujeon@gmail.com</email></author><entry><title type="html">TIL 11: 다중 비동기 완료 처리를 위한 dispatch_group</title><link href="https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks/" rel="alternate" type="text/html" title="TIL 11: 다중 비동기 완료 처리를 위한 dispatch_group" /><published>2020-05-22T00:00:00+09:00</published><updated>2020-05-22T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;다중 비동기 처리가 완료되는 시점에 후속 처리를 하고 싶다면,&lt;br /&gt;
간단히 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 시리즈를 활용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;모든-이미지-다운로드가-완료-됐을-때-로딩바-숨기기&quot;&gt;모든 이미지 다운로드가 완료 됐을 때, 로딩바 숨기기&lt;/h2&gt;

&lt;p&gt;동적으로 화면에 이미지를 보여주기 위해 다운로드가 필요할 때가 있다.
그때 많이 사용하는 방식은 각 이미지가 다운로드될 때마다 이미지 뷰에 표시하도록 해서
로딩바가 표시되더라도 각 이미지 뷰에 표시하도록 하는 것이다.
그런 처리는 일반적인 비동기 처리로 손쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만, 이번에 새로운 요구사항이 생겼다.
모든 이미지가 다운로드될 때까지 중앙에 로딩바를 표시하고,
모두 완료되고 나서 로딩바를 숨긴 후 다른 동작을 할 수 있도록 처리하는 것이다.
이것을 위해서는 &lt;strong&gt;각 비동기 처리(이미지 다운로드)가 완료되는 시점을 알아야 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;iOS에서 비동기 처리를 위한 방법으로 크게 두 가지가 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Operation&lt;/code&gt; 시리즈와 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 시리즈이다.
이번에는 간단하게 모든 이미지 다운로드가 완료됐을 때 로딩바를 숨기면 되므로, 비교적 단순한 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 시리즈를 이용했다.&lt;/p&gt;

&lt;p&gt;그 중에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 시리즈를 이용하면, 각 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 작업들을 &lt;strong&gt;그룹화&lt;/strong&gt;하고
완료되는 시점에 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt; 함수에 정의한 동작을 수행하도록 할 수 있다.&lt;/p&gt;

&lt;p&gt;이것도 한 번 시간을 내어 글로 정리해야겠다.&lt;br /&gt;
정말 정리할 글이 많다… 🤪&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><category term="gcd" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 10: 폰트를 적용했는데 뜬금없는 패딩이 들어가 있다면?</title><link href="https://jamesu.dev/posts/2020/05/21/til-10-when-there-are-unexpected-paddings-for-font-in-text/" rel="alternate" type="text/html" title="TIL 10: 폰트를 적용했는데 뜬금없는 패딩이 들어가 있다면?" /><published>2020-05-21T00:00:00+09:00</published><updated>2020-05-21T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/21/til-10-when-there-are-unexpected-paddings-for-font-in-text</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/21/til-10-when-there-are-unexpected-paddings-for-font-in-text/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;커스텀 폰트를 적용했을 때 글자에 자동으로 추가되는 상하 패딩을 없애려면,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;includeFontPadding&lt;/code&gt; 속성을 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;당황스러운-글자의-상하-패딩&quot;&gt;당황스러운 글자의 상하 패딩&lt;/h2&gt;

&lt;p&gt;커스텀 폰트를 적용하면서 뜬금없는 상하 패딩이 생겨 당황스러웠다.
디자인 요구사항을 만족시키려면 패딩 없이 높이가 딱 맞는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TextView&lt;/code&gt;가 필요했다.
iOS 앱 개발 때와는 다른 당황스러움이었다. (iOS도 가끔 특이한 속성이 있다.)&lt;/p&gt;

&lt;p&gt;구글링을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;includeFontPadding&lt;/code&gt;라는 속성이 있다는 것을 알았고, 그것을 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; 처리함으로써 해결했다.
왜 기본값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;인지 모르겠다…
물론 용도가 있겠지만, 오히려 선택적 옵션이어야 할 것 같은데 말이다. 🙄&lt;/p&gt;

&lt;p&gt;알게 모르게 안드로이드에도 iOS만큼이나 다양한 속성이 있는 것 같다.&lt;br /&gt;
구글이 없었다면, 매번 책을 엄청 뒤지고 있었겠지… 😱&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 9: 안드로이드 커스텀 스타일 적용하기</title><link href="https://jamesu.dev/posts/2020/05/20/til-9-applying-custom-style-in-android/" rel="alternate" type="text/html" title="TIL 9: 안드로이드 커스텀 스타일 적용하기" /><published>2020-05-20T00:00:00+09:00</published><updated>2020-05-20T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/20/til-9-applying-custom-style-in-android</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/20/til-9-applying-custom-style-in-android/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;테마에 일반적인 뷰 스타일을 설정&lt;/strong&gt;해 앱 전반에 공통적으로 스타일을 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스타일-공통화&quot;&gt;스타일 공통화&lt;/h2&gt;

&lt;p&gt;일반적으로 앱을 개발하면, 공통적으로 적용되는 스타일이 있을 것이다.
예를 들면, 특정 앱에서 사용하는 버튼은 일반적으로 8dp의 cornerRadius를 가지고 회색 배경인 버튼일 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 이렇게 자주 쓰이는 공통 버튼을 매번 스타일링 해주기에는 개발자에겐 귀차니즘이 너무 심하다.
실수로 스타일링 구문을 한 줄이라도 빼먹으면, 상이한 디자인의 버튼이 나타날 수 있다.
그래서 &lt;strong&gt;가급적이면 공통 스타일을 정의하고 재활용하는 것이 효율적&lt;/strong&gt;일 것이다.&lt;/p&gt;

&lt;p&gt;이를 위해 다른 개발 환경에서 공통 스타일을 적용한다면,
일반적으로 서브 클래스를 만들어 해당 클래스에 공통 스타일을 적용해놓고 쓸 것이다.
안드로이드에서도 그 방법이 가능하지만, 더 간단한 방법이 있다.&lt;/p&gt;

&lt;p&gt;바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt; 요소로 공통 스타일을 정의하고, &lt;strong&gt;기본적으로 적용한 테마에 해당 스타일을 사용하도록 설정&lt;/strong&gt;하는 것이다.
예를 들어, 공통 버튼 스타일을 적용하고 싶으면, 테마의 &lt;code class=&quot;highlighter-rouge&quot;&gt;buttonStyle&lt;/code&gt; 아이템에 정의한 &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt; 요소를 설정하면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;App.Theme&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parent=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Theme.AppCompat.Light.DarkActionBar&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android:buttonStyle&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;@style/App.Widget.Button&lt;span class=&quot;nt&quot;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;App.Widget.Button&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parent=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@android:style/Widget.Button&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android:background&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;@color/colorPrimary&lt;span class=&quot;nt&quot;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android:textColor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;@android:color/white&lt;span class=&quot;nt&quot;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드와 같이 설정하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;App.Theme&lt;/code&gt; 테마의 버튼은 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;App.Widget.Button&lt;/code&gt; 스타일을 갖는다.
따라서, 앱의 기본 테마로 &lt;code class=&quot;highlighter-rouge&quot;&gt;App.Theme&lt;/code&gt; 테마를 적용하면, 추가적으로 변경하지 않는 한 모든 액티비티가 동일한 버튼 스타일을 갖는 것이다.&lt;/p&gt;

&lt;p&gt;이 밖에도 다양한 뷰에 대해 공통 스타일을 적용할 수 있으므로 참으로 편리하다.
물론, 스타일링뿐 아니라 다른 기능도 적용하고 싶으면 서브 클래스로 정의하는 것이 더 나을 수 있다. 🙄&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 8: HTTP 메시지로 다중 파일 업로드하기</title><link href="https://jamesu.dev/posts/2020/05/19/til-8-uploading-multiple-files-with-http-message/" rel="alternate" type="text/html" title="TIL 8: HTTP 메시지로 다중 파일 업로드하기" /><published>2020-05-19T00:00:00+09:00</published><updated>2020-05-19T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/19/til-8-uploading-multiple-files-with-http-message</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/19/til-8-uploading-multiple-files-with-http-message/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;동일한 파라미터&lt;/strong&gt;에 여러 번에 걸쳐 파일을 추가함으로써, &lt;strong&gt;다중 파일&lt;/strong&gt;을 업로드할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;동일한-파라미터냐-배열-형태의-파라미터냐-그것이-문제로다&quot;&gt;동일한 파라미터냐 배열 형태의 파라미터냐 그것이 문제로다.&lt;/h2&gt;

&lt;p&gt;매번 단일 파일 업로드만 구현하다가 이번에 &lt;strong&gt;다중 파일 업로드&lt;/strong&gt;가 필요한 요구사항이 들어 왔다.&lt;br /&gt;
앱에는 이미 오픈 소스 라이브러리를 사용하지 않고, &lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLSessionTask&lt;/code&gt;를 이용한 네트워크 처리가 되어 있었다.
그래서 기존 코드를 다 뒤집기 보다는 기존처럼 공식 프레임워크로 구현하려 했다.&lt;/p&gt;

&lt;p&gt;직접 구현을 하게 되면, 파일 업로드를 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;의 Content Type으로 API를 호출해야 한다.
그것을 위해 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 메시지의 Request Body를 구성해야 했고, 경험한 적이 있어서 어렵지 않게 기본적인 Body를 구성할 수 있었다.&lt;/p&gt;

&lt;p&gt;처음에는 서버쪽에서 배열로 파일 목록을 받으니 특정한 패턴으로 파라미터를 구분해 파일을 담아야 하는줄 알았다.
실제로 구글링을 할 때도 &lt;code class=&quot;highlighter-rouge&quot;&gt;files[0]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;files[1]&lt;/code&gt; 등과 같이 구분해 담으라는 답변이 있었다.
그럴듯해서 그대로 시도를 했으나 잘 안되어, 파라미터에 문제가 있지 않고 Body 구성에 실수가 있는줄 알고 그 부분만 계속 살펴 봤다.&lt;/p&gt;

&lt;p&gt;결국 &lt;strong&gt;해결책은 매우 간단하게 동일한 파라미터에 차례대로 담으면 되는 것&lt;/strong&gt;이었다. 🙄&lt;br /&gt;
파일이 아닌 다른 데이터도 서버에서 배열로 받는다면, 똑같이 동일한 파라미터에 데이터를 담으면 된다.&lt;/p&gt;

&lt;p&gt;개인적으로 동일한 파라미터로 보내면, 순서를 어떻게 구분할까 싶었는데 그 원리는 생각보다 아주 단순해 보였다.
위에서부터 차례대로 읽으면서 인덱스가 쌓이는 구조로 보인다.&lt;br /&gt;
&lt;strong&gt;두 종류의 데이터를 같은 인덱스로 보내고 싶으면, 순서에 유의해서 데이터를 담아야 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;이렇게 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 메시지를 구성하며 구현하는 것도 재미는 있지만, 역시 신뢰도 높은 오픈 소스 라이브러리가 사용하기에 편하다. 😌&lt;br /&gt;
그래도 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 메시지 구조를 모르고 오픈 소스 라이브러리를 사용하는 것과 알고 쓰는 것은 아주 다르니 꾸준히 공부해야겠다.&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><category term="http" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 7: MRC 속 ARC 조심하기</title><link href="https://jamesu.dev/posts/2020/05/18/til-7-be-careful-about-arc-in-mrc/" rel="alternate" type="text/html" title="TIL 7: MRC 속 ARC 조심하기" /><published>2020-05-18T00:00:00+09:00</published><updated>2020-05-18T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/18/til-7-be-careful-about-arc-in-mrc</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/18/til-7-be-careful-about-arc-in-mrc/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;로 생성되는 객체를 조심하자.&lt;br /&gt;
특히, &lt;strong&gt;객체 생성용 클래스 메소드&lt;/strong&gt;를 조심하자.&lt;br /&gt;
(예: &lt;code class=&quot;highlighter-rouge&quot;&gt;[NSArray array]&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mrc-환경-내부의-arc&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;iOS 개발을 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경에서 해 본 사람이라면, 곳곳에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;가 숨어 있다는 사실을 알 것이다.
그래서 이것을 잘못 알고 사용하면, 잘못된 메모리 참조로 인해 앱 크래시가 발생할 수 있다.
이것이 개발하고 테스트할 때 발견하지 못 하고, 출시한 후 사용자로부터 발견된다면…
급하게 버그를 수정하고 다시 배포하느냐 정신이 없을 것이다. 😱&lt;/p&gt;

&lt;p&gt;과거에 한창 Objective-C로 개발할 때는 숙지하고 있었는데 잠시 몇개월간 Swift의 세계에 있었다고,
까먹고 있어서 개발 중에 크래시가 발생하곤 했다.
다행히 기존에 문제가 있었던 메모리 누수 해결을 하면서 발견해서 상처를 잘 봉합했다.
다음에 꼭 메모리 관련해서 글을 한 번 정리해야겠다.&lt;/p&gt;

&lt;p&gt;간단히 말해서 통상적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경 속에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;로 사용하는 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 메소드를 호출한 경우이다.
보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;로 사용하길 원하는 부분은 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 메소드를 호출하니 문제가 없을 것이다.
그런데, 입문자라면 잘 모를 수 있는 것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIKit&lt;/code&gt; 등과 같은 공식 프레임워크에 정의되어 있는 &lt;strong&gt;객체 생성용 클래스 메소드&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 메소드로 생성하지 않고, &lt;code class=&quot;highlighter-rouge&quot;&gt;[NSArray array]&lt;/code&gt; 메소드와 같은 클래스 메소드로 객체를 생성한 경험이 있을 것이다.
이 경우에 &lt;strong&gt;해당 메소드로 생성한 객체는 이미 &lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 메소드를 호출한 객체이므로, 추가적으로 메모리 해제를 하면 안 된다&lt;/strong&gt;.
다른 말로 &lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt; 메소드를 호출하면 안 된다.
이런 용도의 메소드는 &lt;strong&gt;클래스 이름을 본 딴 Prefix&lt;/strong&gt;를 가지므로, 여러 예시를 본다면 패턴에 익숙해질 것이다.&lt;/p&gt;

&lt;p&gt;또한, &lt;strong&gt;직접 커스텀 클래스에 객체 생성용 클래스 메소드를 정의한다면, 공식 프레임워크와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 객체로 생성하길 권장한다&lt;/strong&gt;.
그렇지 않으면, 혼동되어 더 많은 버그와 실수를 남길 것이다. ☠️&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 6: unowned 레퍼런스 피하기</title><link href="https://jamesu.dev/posts/2020/05/17/til-6-avoiding-unowned-reference/" rel="alternate" type="text/html" title="TIL 6: unowned 레퍼런스 피하기" /><published>2020-05-17T00:00:00+09:00</published><updated>2020-05-17T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/17/til-6-avoiding-unowned-reference</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/17/til-6-avoiding-unowned-reference/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 레퍼런스는 피하고, 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;을 사용하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;unowned-레퍼런스란-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 레퍼런스란? 🤔&lt;/h2&gt;

&lt;p&gt;Swift로 ARC 환경에서 iOS 앱을 개발할 때, 정말 중요한 개념이 있다.&lt;br /&gt;
바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Strong Reference Cycle(강한 참조 순환)&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;다른 것도 중요하지만, 이것을 모르고는 iOS 개발자라 할 수 없다.&lt;br /&gt;
그러므로, 다들 알 것이라 생각하고… 개념은 패스!&lt;/p&gt;

&lt;p&gt;ARC 환경에서 강한 참조 순환이 생겨 버리면, &lt;strong&gt;메모리에 할당된 대상을 해제할지 말지 판단을 하지 못 한다&lt;/strong&gt;.
계속 서로 참조하고 있어, 참조 카운트가 0이 될 수 없기 때문이다.
이를 방지하기 위한 문법으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조가 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조는 &lt;strong&gt;약한 참조&lt;/strong&gt;라 부르고, &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조는 &lt;strong&gt;미소유 참조&lt;/strong&gt;라 부를 수 있다.&lt;br /&gt;
두 참조의 가장 중요한 특징은 &lt;strong&gt;참조 카운트를 증가시키지 않는 것&lt;/strong&gt;이다.
계속 참조하고 있어도 참조 카운트에 영향을 미치지 않기 때문에,
다른 강한 참조가 사라져 메모리가 해제되는 데 지장이 없다.&lt;/p&gt;

&lt;p&gt;또한, &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조는 참조하는 대상의 메모리가 해제되면 자동으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;로 설정되지만,
&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조는 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;로 설정되지 않고 &lt;strong&gt;항상 값이 있다고 가정&lt;/strong&gt;해 버린다.
여기서 생명 주기를 잘못 생각해 이미 메모리 해제된 대상을 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 통해 접근했을 때,
운이 없다면 앱이 그대로 사망할 수 있다. ☠️&lt;/p&gt;

&lt;p&gt;그래서 생명 주기가 확실한 경우에만 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 사용할 것을 &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html&quot; target=&quot;_blank&quot;&gt;Swift 공식 문서&lt;/a&gt;에서도 강조한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use an unowned reference only when you are sure that
the reference always refers to an instance that has not been deallocated.&lt;/p&gt;

  &lt;p&gt;If you try to access the value of an unowned reference
after that instance has been deallocated, &lt;strong&gt;you’ll get a runtime error&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;안전하게-weak-레퍼런스로-통일하자-️&quot;&gt;안전하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 레퍼런스로 통일하자! 👷‍♂️&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 언제 사용하면 좋을 지는 &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html&quot; target=&quot;_blank&quot;&gt;해당 문서&lt;/a&gt;에 예시와 함께 잘 적혀 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조에 비해 Unwrapping을 하지 않아도 되고, 항상 값이 존재한다는 것을 표현할 수도 있다는 것 등등의 다양한 이점이 있지만,
개인적으로는 사용하지 않는 것이 좋다고 생각한다.&lt;/p&gt;

&lt;p&gt;관계를 표현하다가 실수를 할 수도 있고, 요구사항이 바뀌어 수정을 할 때 놓치는 부분이 될 수도 있다.
이런 저런 버그가 생겨 날 가능성이 더 크다고 생각한다.
그런 것들을 감수하면서까지 굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 쓸 필요는 없다고 생각한다.
(정말 필요하다는 타당한 이유가 없다면 🙅‍♂️)&lt;/p&gt;

&lt;p&gt;단순하고 안전하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 지양하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조를 사용하도록 하자.&lt;br /&gt;
개인적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조에 &lt;code class=&quot;highlighter-rouge&quot;&gt;guard&lt;/code&gt; 구문을 사용하면, 왜 이렇게 마음이 편안한지 모르겠다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="swift" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 5: Network Activity Indicator가 사라지다</title><link href="https://jamesu.dev/posts/2020/05/16/til-5-network-activity-indicator-is-deprecated/" rel="alternate" type="text/html" title="TIL 5: Network Activity Indicator가 사라지다" /><published>2020-05-16T00:00:00+09:00</published><updated>2020-05-16T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/16/til-5-network-activity-indicator-is-deprecated</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/16/til-5-network-activity-indicator-is-deprecated/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;를 보여줄 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;network-activity-indicator란-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;란? 🤔&lt;/h2&gt;

&lt;p&gt;iOS 앱에서 네트워크 연결이 길어지는 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;라는 &lt;strong&gt;네트워크 연결중 표시를 위한 UI&lt;/strong&gt;가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/network_activity_indicator.png&quot; alt=&quot;Network Activity Indicator&quot; /&gt;
&lt;em&gt;상태바 좌측에서 확인할 수 있다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이것을 본 사람도 있고 아닌 사람도 있을 것이다.
왜냐하면, 화면 모양에 따라 보여지는 경우가 있고 아닌 경우도 있기 때문이다.
또한, 앱 개발자가 이것을 보여지도록 처리했는지에 따라 앱을 사용하는 내내 볼 수도 있고 못 볼 수도 있다.
이것은 순전히 개발자에게 달려있다.&lt;/p&gt;

&lt;p&gt;보여 줄 수 있는 화면이라면, 보여주는 것이 사용자를 위한 배려라 생각들지 않는가?&lt;br /&gt;
다음과 같이 애플의 &lt;strong&gt;Human Interface Guidelines(이하 HIG)&lt;/strong&gt; 문서의
&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/ios/controls/progress-indicators/&quot; target=&quot;_blank&quot;&gt;Progress Indicators 내용&lt;/a&gt;에 따르면,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;는 네트워크 연결이 길어지는 경우에 보여주고,
통신이 빠른 동작에는 보여주지 말라는 말이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Show this indicator only for network operations lasting more than a few seconds.&lt;/strong&gt;&lt;br /&gt;
Don’t display the indicator for quick network operations
because it’s likely to disappear before anyone notices its presence
or realizes what it’s meant to communicate.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앱을 만들 때마다 이것을 신경 쓰는 것은 매우 귀찮은 일이 될 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;구현-할지-말지-더-이상-신경쓰지-않아도-된다-&quot;&gt;구현 할지 말지 더 이상 신경쓰지 않아도 된다! 😏&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/ios/controls/progress-indicators/&quot; target=&quot;_blank&quot;&gt;동일한 페이지&lt;/a&gt;의 바로 윗 부분에
&lt;strong&gt;“iOS 13 이상이나 edge-to-edge 디스플레이의 기기에서는 더 이상 해당 UI를 제공하지 않는다”&lt;/strong&gt;는 내용도 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The network activity indicator is deprecated in iOS 13 and on devices with edge-to-edge displays.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대체하는 API가 나온 것이 아닌 완전한 &lt;strong&gt;Deprecated&lt;/strong&gt;이다.
앞으로 애플에서도 해당 UI에 대해 생각하지 않겠다는 것이다.
그 대신 자주 사용하는 로딩중 표시를 위한 UI인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity Indicator&lt;/code&gt;를 사용하면 된다.&lt;/p&gt;

&lt;p&gt;사라질 기능이니 앞으로 새로 개발하거나 개선하는 앱에서는 굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;를 사용하지 않아도 된다.
아주 미세한 짐 하나를 덜어낸 것 같다. 🙄&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 4: MRC는 괴로워</title><link href="https://jamesu.dev/posts/2020/05/15/til-4-mrc-is-painful/" rel="alternate" type="text/html" title="TIL 4: MRC는 괴로워" /><published>2020-05-15T00:00:00+09:00</published><updated>2020-05-15T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/15/til-4-mrc-is-painful</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/15/til-4-mrc-is-painful/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;는 매우 특별한 경우가 아니라면 쓰지말자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mrc란-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;란? 🤔&lt;/h2&gt;

&lt;p&gt;현재 사내에서 레거시 코드를 유지보수하고 있어서 그런지 겪고 있는 어려움이 있다.&lt;br /&gt;
특히, 지금은 자동으로 메모리를 관리해주는 GC(Garbage Collection), ARC(Automatic Reference Counting)
등의 환경이 당연하다시피 여겨지고 있기 때문에 더 와 닿는다.&lt;/p&gt;

&lt;p&gt;바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC(Manual Reference Counting)&lt;/code&gt; 환경이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;는 iOS의 자동 메모리 관리 환경인 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;의 반대되는 개념이다.&lt;br /&gt;
말그대로 &lt;strong&gt;개발자가 수동으로 메모리를 관리&lt;/strong&gt;해줘야 한다.
C, C++ 등과 함께 코딩을 해 본 사람이라면, 뭔지 바로 알 것이다.
개발자가 사용하기 위해 메모리에 공간을 할당했으면, 다 사용한 후에 직접 제거해줘야 한다.
그래야 해당 공간을 재활용할 수 있기 때문이다.
이것을 꼼꼼하게 하지 않고 놓치면, 메모리 누수 지옥이 시작되는 것이다.&lt;br /&gt;
과거에는 성능 최적화를 위해 직접 메모리 관리를 하는 경우가 있었지만,
현재는 세월이 많이 흘러 자동 메모리 관리 환경이 매우 잘 되어 있다.
따라서 &lt;strong&gt;특별한 경우를 제외한 일반적인 경우에서는 굳이 직접 메모리 관리를 할 필요가 없다&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;메모리-누수-지옥-&quot;&gt;메모리 누수 지옥 🔥&lt;/h2&gt;

&lt;p&gt;현재 사내에서 내가 맡고 있는 앱 일부는 Objective-C(이하 Obj-C)를 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경에서 사용하고 있어 직접 메모리 관리를 해야 한다.
수동 메모리 관리가 필요한 중요한 처리를 하지 않는 데도 말이다.&lt;/p&gt;

&lt;p&gt;기존 앱들이 잘 되어 있었으면 괜찮지만, 메모리 누수가 다수 발견되어 해결하는 데 많은 고생을 하곤 했다.&lt;br /&gt;
Obj-C도 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 환경을 사용하는 데 무리가 없는데, 굳이 메모리 누수를 만들어 내며 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;를 고수했는지 알 수가 없다.
(물론, &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 환경도 메모리 누수 방지를 위한 처리가 필요하지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;는 더 꼼꼼하게 처리해야 한다.)&lt;br /&gt;
실제로 생산성도 떨어지고 메모리 누수와 버그도 발생하기 쉬워 &lt;strong&gt;비효율적&lt;/strong&gt;이었다.
(그래서 어떤 앱의 경우, 나에게 기회가 생겨 추후 유지보수를 위해 한 달의 시간을 투자해 Swift 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 환경으로 완전 포팅했다. 😂)&lt;/p&gt;

&lt;h2 id=&quot;앞으로는-웬만하면-무조건-arc&quot;&gt;앞으로는 웬만하면 무조건 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;그렇게 기존처럼 오늘도 메모리 누수 지옥을 해결하기 위해 많은 노력을 했다. (아직 남아있을 수도 있겠지만 😤)&lt;br /&gt;
앞으로 가능하면 새 프로젝트는 무조건 (정말 특별한 경우를 제외하곤) &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 환경으로 시작하려 한다.
메모리 누수 지옥을 해결하는 노력을 다른 데 쓰면 앱의 퀄리티를 더 높일 수 있을 것 같다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 3: 안드로이드 테스트는 힘들어 (feat. 파편화)</title><link href="https://jamesu.dev/posts/2020/05/14/til-3-android-testing-is-so-hard-feat-fragmentation/" rel="alternate" type="text/html" title="TIL 3: 안드로이드 테스트는 힘들어 (feat. 파편화)" /><published>2020-05-14T00:00:00+09:00</published><updated>2020-05-14T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/14/til-3-android-testing-is-so-hard-feat-fragmentation</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/14/til-3-android-testing-is-so-hard-feat-fragmentation/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이미 알고 있었던 것처럼 &lt;strong&gt;안드로이드의 파편화&lt;/strong&gt;는 끔찍했다.&lt;br /&gt;
하지만, 더 끔찍했던 것은 &lt;strong&gt;앱의 완성도&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt; 방지는 기본 중의 기본! (특히, 모바일 개발에서는 필수!)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SwipeRefreshLayout&lt;/code&gt; 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;가 연속으로 중첩된 경우,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nestedScrollingEnabled&lt;/code&gt; 옵션을 이용해 새로고침 동작이 중복되지 않도록 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;끔찍한-안드로이드의-파편화&quot;&gt;끔찍한 안드로이드의 파편화&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;assets/figure_1.jpg&quot; alt=&quot;Figure 1&quot; /&gt;
&lt;em&gt;내 표정도 이와 같다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;오늘 하루 날을 잡아 사내에서 개발한 안드로이드 앱 하나의 테스트를 진행하고 이슈를 처리하는 시간을 가졌다.
내가 직접 만든 앱이었다면, 알 수 없는 자신감으로 버그가 적을 것이라 예상할 수 있지만, 인수인계 받은 앱이라 정상 작동을 확신하지 못했다.
그렇게 OS 버전과 제조사를 고려해 Android 4.4 ~ 9.0 버전과 삼성 및 LG의 핸드폰을 대상으로 테스트를 진행했다.&lt;/p&gt;

&lt;p&gt;버전 이슈가 없길 희망했지만, 결과는 희망을 배신했다.&lt;br /&gt;
아무래도 이렇게 다양한 버전과 기기를 대상으로 테스트한 것은 처음이라 그런지 OS 버전에 따른 이슈가 존재했다.
특히, 4.4 버전의 이슈가 대부분이었고, 다행히 다른 버전에서는 큰 이슈가 없었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/figure_2.png&quot; alt=&quot;Figure 2&quot; title=&quot;Figure 2&quot; /&gt;
&lt;em&gt;안드로이드 OS 버전 파편화&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;사전에 최소 OS 버전을 무엇으로 할 지 조사를 한 결과, &lt;strong&gt;약 95% 이상을 커버하려면 4.4 버전(KitKat) 이상&lt;/strong&gt;이어야 했다.
물론, 4.4 버전을 사용하는 사용자는 매우 적을 것이라 생각하지만, 업무 도메인 특성상 옛날 폰을 사용하는 사용자가 존재할 가능성이 있기 때문이다.
아무튼 4.4 버전에서만 발생하는 이슈가 많아 5.0 버전부터 지원할 지 논의할 예정이다.&lt;/p&gt;

&lt;p&gt;이처럼 안드로이드는 iOS에 비해 버전 파편화와 기기 파편화가 심해서 예상했던 결과였다.
(기기 파편화를 고려해 여러 제조사를 테스트하고 싶었으나 해당 테스트 센터에서는 준비된 기기가 없었다.)&lt;/p&gt;

&lt;p&gt;정말 끔찍했던 것은 파편화의 문제가 아니라 &lt;strong&gt;앱의 완성도&lt;/strong&gt;였다.&lt;br /&gt;
개인적으로 앱을 개발할 때 앱의 완성도를 신경쓰는 편이다.
iOS 버전과의 &lt;strong&gt;동작의 일관성&lt;/strong&gt;을 당연하고, 특별한 경우를 제외하고는 &lt;strong&gt;UI의 일관성&lt;/strong&gt;도 유지하려고 한다.
그런데 여기서 당연하게 되어야 할 동작의 일관성에 버그가 꽤나 발견됐다.
앞서 개발 후 보유한 기기를 토대로 테스트를 진행했는데도 버그가 존재한 채로 출시한 것이다.
요구사항에 대한 기본적인 테스트도 진행하지 않으며 개발한 것이 눈에 보였다.
(중요한 요구사항 일부가 정상적으로 반영되지 않았다.)&lt;/p&gt;

&lt;p&gt;이제는 인수인계를 받은 앱이기 때문에 지금부터 발생하는 버그는 내 책임이 될 것이다.&lt;br /&gt;
나도 누군가에게 내가 받은 느낌을 주지 않도록 앱의 완성도를 끌어 올리는데 더욱 노력해야겠다. 💪&lt;/p&gt;

&lt;h2 id=&quot;npe-방지를-놓치는-실수는-하지-말자&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt; 방지를 놓치는 실수는 하지 말자&lt;/h2&gt;

&lt;p&gt;앞서 말한 버그 중 하나는 개발자라면 누구나 맞이한 적이 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Null Pointer Exception (이하 NPE)&lt;/code&gt;였다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt;는 런타임 에러 중 하나로, &lt;strong&gt;메모리에 할당되지 않은 주소에 접근을 시도한 경우 발생하는 예외&lt;/strong&gt;이다.&lt;br /&gt;
서버 개발이라면, 공통 예외 처리를 통해 서버가 종료되지 않고 에러를 반환하는 식의 처리가 가능하다.
하지만, &lt;strong&gt;모바일 개발에서는 예외 처리를 놓치면 앱이 강제 종료(Crash)&lt;/strong&gt;되기 때문에 매우 치명적이다.
사용하던 앱이 갑자기 알 수 없이 꺼진다면 누구라도 쓰고 싶지 않을 것이다.
그래서 서버 개발에서도 중요하겠지만, 특히 모바일 개발에서 예외 처리는 너무 중요한 부분이다.&lt;/p&gt;

&lt;p&gt;그 중에서도 &lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt;는 놓치기 쉬운 예외이다.&lt;br /&gt;
너무나 당연하게 주소에 값이 할당되어 있다고 생각하고 문법을 작성하면, 어느 순간 맞이할 수 있을 것이다.
개발자가 예상할 수 있는 예외는 해당 부분에 예외 처리를 하면 되지만,
&lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt;는 기본 문법의 실수로 발생하는 예외이기 때문에 더욱 주의가 필요하다.&lt;/p&gt;

&lt;p&gt;위에서 발생한 버그는 앱에서 로그인한 후에 처음으로 맞이하는 화면에서 간헐적으로 발생하던 버그이다.
나라도 로그인하자마자 앱이 꺼진다면 어이가 없을 것이다.
기존에 발견되지 않은 이유는 기기와 OS 버전에 따라 발생했던 버그라 우연히 발견되지 않았다.
역시나 안드로이드는 파편화에 대한 테스트 진행이 필수인 것 같다.&lt;/p&gt;

&lt;p&gt;앞으로 나도 더 꼼꼼하게 놓치지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt; 예외 처리를 해야겠다.
(욕먹기 싫다면 🙄)&lt;/p&gt;

&lt;h2 id=&quot;새로고침-동작이-엉뚱한-부분에서-시작되는-경우&quot;&gt;새로고침 동작이 엉뚱한 부분에서 시작되는 경우&lt;/h2&gt;

&lt;p&gt;발견한 또 다른 버그는 UI 이슈였다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;를 사용할 때, &lt;strong&gt;당겨서 새로고침&lt;/strong&gt; 동작을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;SwipeRefreshLayout&lt;/code&gt;를 사용했다.
그런데, &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt; 안의 항목 내부에도 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;를 사용해서 중첩된 구조였다.
새로고침 동작은 가장 외부에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;를 당겨서 수행하고 싶었지만,
저 아래로 스크롤한 후에 항목 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;를 당기는 경우에도 새로고침 동작이 수행되는 것이었다.&lt;/p&gt;

&lt;p&gt;그래서 알아본 결과, 항목 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;nestedScrollingEnabled&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정하면
외부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;에 대해서만 새로고침 동작이 작동하게 된다.&lt;/p&gt;

&lt;p&gt;참고로 해당 옵션은 &lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt;에서도 설정할 수 있지만, 4.4 버전을 지원하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt;이 아닌 코드로 설정해야 한다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;recyclerView.setNestedScrollingEnabled(false)&lt;/code&gt;와 같이 말이다.&lt;/p&gt;

&lt;p&gt;iOS 개발이 메인이지만, 안드로이드 개발 경험도 점점 쌓이고 있어 재밌는 것 같다. 😂&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="test" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 2: 팀 간 의사소통의 중요성</title><link href="https://jamesu.dev/posts/2020/05/13/til-2-importance-of-communication-between-teams/" rel="alternate" type="text/html" title="TIL 2: 팀 간 의사소통의 중요성" /><published>2020-05-13T00:00:00+09:00</published><updated>2020-05-13T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/13/til-2-importance-of-communication-between-teams</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/13/til-2-importance-of-communication-between-teams/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;팀 간 의사소통의 핵심은 &lt;strong&gt;서로를 위한 배려&lt;/strong&gt;이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;당연하지만-쉽지-않은-의사소통&quot;&gt;당연하지만 쉽지 않은 의사소통&lt;/h2&gt;

&lt;p&gt;다수의 팀으로 이루어진 회사에서 팀 간 의사소통은 당연하고 중요하지만 원하는 대로 이뤄지지 않는 경우가 많다.
회식을 하면 종종 타 팀과의 의사소통에 대한 불만을 듣는다.
겉으로 보기에 사이가 친하고 의사소통에 문제가 없어 보이는 멤버들 간에도 앙금이 쌓여 있어 불만을 토로 하는 것을 보면,
그런 사이에서도 일적인 의사소통은 정말 힘들 수 있다는 생각이 든다.
그래서 일 자체가 아닌 의사소통으로 인해 스트레스가 쌓이는 것을 보면 안타깝다는 생각도 든다.&lt;/p&gt;

&lt;p&gt;나의 경우에는 위 사례에서의 멤버가 앙금이 쌓여 있는 대상과 의사소통을 할 때, 특별히 까다롭지도 답답하지도 어렵지도 않다는 느낌을 받았다.
더불어 물론 의사소통에 의한 스트레스도 받고 있지 않다.
오히려 나와 일하는 것이 좋다는 이야기도 들어, 그런 이야기를 들을 때마다 뿌듯함이 함께한다.&lt;/p&gt;

&lt;h2 id=&quot;의사소통의-핵심&quot;&gt;의사소통의 핵심?&lt;/h2&gt;

&lt;p&gt;그렇다면, 나와 의사소통에 어려움을 겪고 있는 멤버와의 차이점은 무엇일까?&lt;br /&gt;
개인적으로 생각하기엔 좋은 의사소통의 핵심은 &lt;strong&gt;서로를 위한 배려&lt;/strong&gt;라고 생각한다.&lt;/p&gt;

&lt;p&gt;이것도 어찌 보면 당연하지만 제대로 실천되고 있지 않아 어려움을 겪는 사람들이 많다고 생각한다.
업무에 대한 이야기 함에 있어 상대방을 배려해 어느 정도 책임을 나눠 가지고(책임을 전가하지 않고),
어느 정도 의견을 수용하려 하고(항상 내가 옳다는 생각을 버리고),
어느 정도 서로의 역할을 이해하면(역할에 따라 앎의 정도가 다르다는 것을 이해하면),
서로 간의 신뢰감도 쌓이고 업무적으로 더 친밀해진다는 것을 느낄 수 있다.
그런 관계가 되고 나면, 팀 간 의사소통으로 인해 발생하는 스트레스도 없고 업무도 잘 처리되는 선순환이 이뤄지는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;앞으로도 이런 마음가짐을 토대로 팀 간 의사소통에 대해 긍정적으로 생각하고 실천하도록 하자.&lt;br /&gt;
지금까지 나도 모르게 의사소통을 잘 해왔다는 생각에 마음이 매우 뿌듯한 하루였다. 🙂&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="idea" /><summary type="html">TL;DR</summary></entry></feed>