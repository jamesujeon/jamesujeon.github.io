<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko_KR"><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://jamesu.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jamesu.dev/" rel="alternate" type="text/html" hreflang="ko_KR" /><updated>2020-05-26T01:12:04+09:00</updated><id>https://jamesu.dev/</id><title type="html">Jamesu Devlog</title><subtitle>Dev Blog by James Minsu Jeon</subtitle><author><name>jamesujeon</name><email>jamesujeon@gmail.com</email></author><entry><title type="html">TIL 8: HTTP 메시지로 다중 파일 업로드하기</title><link href="https://jamesu.dev/posts/2020/05/19/til-8-uploading-multiple-files-with-http-message/" rel="alternate" type="text/html" title="TIL 8: HTTP 메시지로 다중 파일 업로드하기" /><published>2020-05-19T00:00:00+09:00</published><updated>2020-05-19T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/19/til-8-uploading-multiple-files-with-http-message</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/19/til-8-uploading-multiple-files-with-http-message/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;동일한 파라미터&lt;/strong&gt;에 여러 번에 걸쳐 파일을 추가함으로써, &lt;strong&gt;다중 파일&lt;/strong&gt;을 업로드할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;동일한-파라미터냐-배열-형태의-파라미터냐-그것이-문제로다&quot;&gt;동일한 파라미터냐 배열 형태의 파라미터냐 그것이 문제로다.&lt;/h2&gt;

&lt;p&gt;매번 단일 파일 업로드만 구현하다가 이번에 &lt;strong&gt;다중 파일 업로드&lt;/strong&gt;가 필요한 요구사항이 들어 왔다.&lt;br /&gt;
앱에는 이미 오픈 소스 라이브러리를 사용하지 않고, &lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLSessionTask&lt;/code&gt;를 이용한 네트워크 처리가 되어 있었다.
그래서 기존 코드를 다 뒤집기 보다는 기존처럼 공식 프레임워크로 구현하려 했다.&lt;/p&gt;

&lt;p&gt;직접 구현을 하게 되면, 파일 업로드를 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;의 Content Type으로 API를 호출해야 한다.
그것을 위해 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 메시지의 Request Body를 구성해야 했고, 경험한 적이 있어서 어렵지 않게 기본적인 Body를 구성할 수 있었다.&lt;/p&gt;

&lt;p&gt;처음에는 서버쪽에서 배열로 파일 목록을 받으니 특정한 패턴으로 파라미터를 구분해 파일을 담아야 하는줄 알았다.
실제로 구글링을 할 때도 &lt;code class=&quot;highlighter-rouge&quot;&gt;files[0]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;files[1]&lt;/code&gt; 등과 같이 구분해 담으라는 답변이 있었다.
그럴듯해서 그대로 시도를 했으나 잘 안되어, 파라미터에 문제가 있지 않고 Body 구성에 실수가 있는줄 알고 그 부분만 계속 살펴 봤다.&lt;/p&gt;

&lt;p&gt;결국 &lt;strong&gt;해결책은 매우 간단하게 동일한 파라미터에 차례대로 담으면 되는 것&lt;/strong&gt;이었다. 🙄&lt;br /&gt;
파일이 아닌 다른 데이터도 서버에서 배열로 받는다면, 똑같이 동일한 파라미터에 데이터를 담으면 된다.&lt;/p&gt;

&lt;p&gt;개인적으로 동일한 파라미터로 보내면, 순서를 어떻게 구분할까 싶었는데 그 원리는 생각보다 아주 단순해 보였다.
위에서부터 차례대로 읽으면서 인덱스가 쌓이는 구조로 보인다.&lt;br /&gt;
&lt;strong&gt;두 종류의 데이터를 같은 인덱스로 보내고 싶으면, 순서에 유의해서 데이터를 담아야 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;이렇게 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 메시지를 구성하며 구현하는 것도 재미는 있지만, 역시 신뢰도 높은 오픈 소스 라이브러리가 사용하기에 편하다. 😌&lt;br /&gt;
그래도 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 메시지 구조를 모르고 오픈 소스 라이브러리를 사용하는 것과 알고 쓰는 것은 아주 다르니 꾸준히 공부해야겠다.&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><category term="http" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 7: MRC 속 ARC 조심하기</title><link href="https://jamesu.dev/posts/2020/05/18/til-7-be-careful-about-arc-in-mrc/" rel="alternate" type="text/html" title="TIL 7: MRC 속 ARC 조심하기" /><published>2020-05-18T00:00:00+09:00</published><updated>2020-05-18T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/18/til-7-be-careful-about-arc-in-mrc</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/18/til-7-be-careful-about-arc-in-mrc/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;로 생성되는 객체를 조심하자.&lt;br /&gt;
특히, &lt;strong&gt;객체 생성용 클래스 메소드&lt;/strong&gt;를 조심하자.&lt;br /&gt;
(예: &lt;code class=&quot;highlighter-rouge&quot;&gt;[NSArray array]&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mrc-환경-내부의-arc&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;iOS 개발을 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경에서 해 본 사람이라면, 곳곳에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;가 숨어 있다는 사실을 알 것이다.
그래서 이것을 잘못 알고 사용하면, 잘못된 메모리 참조로 인해 앱 크래시가 발생할 수 있다.
이것이 개발하고 테스트할 때 발견하지 못 하고, 출시한 후 사용자로부터 발견된다면…
급하게 버그를 수정하고 다시 배포하느냐 정신이 없을 것이다. 😱&lt;/p&gt;

&lt;p&gt;과거에 한창 Objective-C로 개발할 때는 숙지하고 있었는데 잠시 몇개월간 Swift의 세계에 있었다고,
까먹고 있어서 개발 중에 크래시가 발생하곤 했다.
다행히 기존에 문제가 있었던 메모리 누수 해결을 하면서 발견해서 상처를 잘 봉합했다.
다음에 꼭 메모리 관련해서 글을 한 번 정리해야겠다.&lt;/p&gt;

&lt;p&gt;간단히 말해서 통상적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경 속에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;로 사용하는 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 메소드를 호출한 경우이다.
보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;로 사용하길 원하는 부분은 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 메소드를 호출하니 문제가 없을 것이다.
그런데, 입문자라면 잘 모를 수 있는 것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIKit&lt;/code&gt; 등과 같은 공식 프레임워크에 정의되어 있는 &lt;strong&gt;객체 생성용 클래스 메소드&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 메소드로 생성하지 않고, &lt;code class=&quot;highlighter-rouge&quot;&gt;[NSArray array]&lt;/code&gt; 메소드와 같은 클래스 메소드로 객체를 생성한 경험이 있을 것이다.
이 경우에 &lt;strong&gt;해당 메소드로 생성한 객체는 이미 &lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 메소드를 호출한 객체이므로, 추가적으로 메모리 해제를 하면 안 된다&lt;/strong&gt;.
다른 말로 &lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt; 메소드를 호출하면 안 된다.
이런 용도의 메소드는 &lt;strong&gt;클래스 이름을 본 딴 Prefix&lt;/strong&gt;를 가지므로, 여러 예시를 본다면 패턴에 익숙해질 것이다.&lt;/p&gt;

&lt;p&gt;또한, &lt;strong&gt;직접 커스텀 클래스에 객체 생성용 클래스 메소드를 정의한다면, 공식 프레임워크와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 객체로 생성하길 권장한다&lt;/strong&gt;.
그렇지 않으면, 혼동되어 더 많은 버그와 실수를 남길 것이다. ☠️&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 6: unowned 레퍼런스 피하기</title><link href="https://jamesu.dev/posts/2020/05/17/til-6-avoiding-unowned-reference/" rel="alternate" type="text/html" title="TIL 6: unowned 레퍼런스 피하기" /><published>2020-05-17T00:00:00+09:00</published><updated>2020-05-17T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/17/til-6-avoiding-unowned-reference</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/17/til-6-avoiding-unowned-reference/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 레퍼런스는 피하고, 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;을 사용하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;unowned-레퍼런스란-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 레퍼런스란? 🤔&lt;/h2&gt;

&lt;p&gt;Swift로 ARC 환경에서 iOS 앱을 개발할 때, 정말 중요한 개념이 있다.&lt;br /&gt;
바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Strong Reference Cycle(강한 참조 순환)&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;다른 것도 중요하지만, 이것을 모르고는 iOS 개발자라 할 수 없다.&lt;br /&gt;
그러므로, 다들 알 것이라 생각하고… 개념은 패스!&lt;/p&gt;

&lt;p&gt;ARC 환경에서 강한 참조 순환이 생겨 버리면, &lt;strong&gt;메모리에 할당된 대상을 해제할지 말지 판단을 하지 못 한다&lt;/strong&gt;.
계속 서로 참조하고 있어, 참조 카운트가 0이 될 수 없기 때문이다.
이를 방지하기 위한 문법으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조가 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조는 &lt;strong&gt;약한 참조&lt;/strong&gt;라 부르고, &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조는 &lt;strong&gt;미소유 참조&lt;/strong&gt;라 부를 수 있다.&lt;br /&gt;
두 참조의 가장 중요한 특징은 &lt;strong&gt;참조 카운트를 증가시키지 않는 것&lt;/strong&gt;이다.
계속 참조하고 있어도 참조 카운트에 영향을 미치지 않기 때문에,
다른 강한 참조가 사라져 메모리가 해제되는 데 지장이 없다.&lt;/p&gt;

&lt;p&gt;또한, &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조는 참조하는 대상의 메모리가 해제되면 자동으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;로 설정되지만,
&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조는 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;로 설정되지 않고 &lt;strong&gt;항상 값이 있다고 가정&lt;/strong&gt;해 버린다.
여기서 생명 주기를 잘못 생각해 이미 메모리 해제된 대상을 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 통해 접근했을 때,
운이 없다면 앱이 그대로 사망할 수 있다. ☠️&lt;/p&gt;

&lt;p&gt;그래서 생명 주기가 확실한 경우에만 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 사용할 것을 &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html&quot; target=&quot;_blank&quot;&gt;Swift 공식 문서&lt;/a&gt;에서도 강조한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use an unowned reference only when you are sure that
the reference always refers to an instance that has not been deallocated.&lt;/p&gt;

  &lt;p&gt;If you try to access the value of an unowned reference
after that instance has been deallocated, &lt;strong&gt;you’ll get a runtime error&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;안전하게-weak-레퍼런스로-통일하자-️&quot;&gt;안전하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 레퍼런스로 통일하자! 👷‍♂️&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 언제 사용하면 좋을 지는 &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html&quot; target=&quot;_blank&quot;&gt;해당 문서&lt;/a&gt;에 예시와 함께 잘 적혀 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조에 비해 Unwrapping을 하지 않아도 되고, 항상 값이 존재한다는 것을 표현할 수도 있다는 것 등등의 다양한 이점이 있지만,
개인적으로는 사용하지 않는 것이 좋다고 생각한다.&lt;/p&gt;

&lt;p&gt;관계를 표현하다가 실수를 할 수도 있고, 요구사항이 바뀌어 수정을 할 때 놓치는 부분이 될 수도 있다.
이런 저런 버그가 생겨 날 가능성이 더 크다고 생각한다.
그런 것들을 감수하면서까지 굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 쓸 필요는 없다고 생각한다.
(정말 필요하다는 타당한 이유가 없다면 🙅‍♂️)&lt;/p&gt;

&lt;p&gt;단순하고 안전하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 지양하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조를 사용하도록 하자.&lt;br /&gt;
개인적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조에 &lt;code class=&quot;highlighter-rouge&quot;&gt;guard&lt;/code&gt; 구문을 사용하면, 왜 이렇게 마음이 편안한지 모르겠다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="swift" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 5: Network Activity Indicator가 사라지다</title><link href="https://jamesu.dev/posts/2020/05/16/til-5-network-activity-indicator-is-deprecated/" rel="alternate" type="text/html" title="TIL 5: Network Activity Indicator가 사라지다" /><published>2020-05-16T00:00:00+09:00</published><updated>2020-05-16T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/16/til-5-network-activity-indicator-is-deprecated</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/16/til-5-network-activity-indicator-is-deprecated/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;를 보여줄 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;network-activity-indicator란-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;란? 🤔&lt;/h2&gt;

&lt;p&gt;iOS 앱에서 네트워크 연결이 길어지는 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;라는 &lt;strong&gt;네트워크 연결중 표시를 위한 UI&lt;/strong&gt;가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/network_activity_indicator.png&quot; alt=&quot;Network Activity Indicator&quot; /&gt;
&lt;em&gt;상태바 좌측에서 확인할 수 있다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이것을 본 사람도 있고 아닌 사람도 있을 것이다.
왜냐하면, 화면 모양에 따라 보여지는 경우가 있고 아닌 경우도 있기 때문이다.
또한, 앱 개발자가 이것을 보여지도록 처리했는지에 따라 앱을 사용하는 내내 볼 수도 있고 못 볼 수도 있다.
이것은 순전히 개발자에게 달려있다.&lt;/p&gt;

&lt;p&gt;보여 줄 수 있는 화면이라면, 보여주는 것이 사용자를 위한 배려라 생각들지 않는가?&lt;br /&gt;
다음과 같이 애플의 &lt;strong&gt;Human Interface Guidelines(이하 HIG)&lt;/strong&gt; 문서의
&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/ios/controls/progress-indicators/&quot; target=&quot;_blank&quot;&gt;Progress Indicators 내용&lt;/a&gt;에 따르면,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;는 네트워크 연결이 길어지는 경우에 보여주고,
통신이 빠른 동작에는 보여주지 말라는 말이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Show this indicator only for network operations lasting more than a few seconds.&lt;/strong&gt;&lt;br /&gt;
Don’t display the indicator for quick network operations
because it’s likely to disappear before anyone notices its presence
or realizes what it’s meant to communicate.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앱을 만들 때마다 이것을 신경 쓰는 것은 매우 귀찮은 일이 될 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;구현-할지-말지-더-이상-신경쓰지-않아도-된다-&quot;&gt;구현 할지 말지 더 이상 신경쓰지 않아도 된다! 😏&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/ios/controls/progress-indicators/&quot; target=&quot;_blank&quot;&gt;동일한 페이지&lt;/a&gt;의 바로 윗 부분에
&lt;strong&gt;“iOS 13 이상이나 edge-to-edge 디스플레이의 기기에서는 더 이상 해당 UI를 제공하지 않는다”&lt;/strong&gt;는 내용도 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The network activity indicator is deprecated in iOS 13 and on devices with edge-to-edge displays.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대체하는 API가 나온 것이 아닌 완전한 &lt;strong&gt;Deprecated&lt;/strong&gt;이다.
앞으로 애플에서도 해당 UI에 대해 생각하지 않겠다는 것이다.
그 대신 자주 사용하는 로딩중 표시를 위한 UI인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity Indicator&lt;/code&gt;를 사용하면 된다.&lt;/p&gt;

&lt;p&gt;사라질 기능이니 앞으로 새로 개발하거나 개선하는 앱에서는 굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Network Activity Indicator&lt;/code&gt;를 사용하지 않아도 된다.
아주 미세한 짐 하나를 덜어낸 것 같다. 🙄&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 4: MRC는 괴로워</title><link href="https://jamesu.dev/posts/2020/05/15/til-4-mrc-is-painful/" rel="alternate" type="text/html" title="TIL 4: MRC는 괴로워" /><published>2020-05-15T00:00:00+09:00</published><updated>2020-05-15T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/15/til-4-mrc-is-painful</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/15/til-4-mrc-is-painful/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;는 매우 특별한 경우가 아니라면 쓰지말자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mrc란-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;란? 🤔&lt;/h2&gt;

&lt;p&gt;현재 사내에서 레거시 코드를 유지보수하고 있어서 그런지 겪고 있는 어려움이 있다.&lt;br /&gt;
특히, 지금은 자동으로 메모리를 관리해주는 GC(Garbage Collection), ARC(Automatic Reference Counting)
등의 환경이 당연하다시피 여겨지고 있기 때문에 더 와 닿는다.&lt;/p&gt;

&lt;p&gt;바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC(Manual Reference Counting)&lt;/code&gt; 환경이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;는 iOS의 자동 메모리 관리 환경인 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;의 반대되는 개념이다.&lt;br /&gt;
말그대로 &lt;strong&gt;개발자가 수동으로 메모리를 관리&lt;/strong&gt;해줘야 한다.
C, C++ 등과 함께 코딩을 해 본 사람이라면, 뭔지 바로 알 것이다.
개발자가 사용하기 위해 메모리에 공간을 할당했으면, 다 사용한 후에 직접 제거해줘야 한다.
그래야 해당 공간을 재활용할 수 있기 때문이다.
이것을 꼼꼼하게 하지 않고 놓치면, 메모리 누수 지옥이 시작되는 것이다.&lt;br /&gt;
과거에는 성능 최적화를 위해 직접 메모리 관리를 하는 경우가 있었지만,
현재는 세월이 많이 흘러 자동 메모리 관리 환경이 매우 잘 되어 있다.
따라서 &lt;strong&gt;특별한 경우를 제외한 일반적인 경우에서는 굳이 직접 메모리 관리를 할 필요가 없다&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;메모리-누수-지옥-&quot;&gt;메모리 누수 지옥 🔥&lt;/h2&gt;

&lt;p&gt;현재 사내에서 내가 맡고 있는 앱 일부는 Objective-C(이하 Obj-C)를 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경에서 사용하고 있어 직접 메모리 관리를 해야 한다.
수동 메모리 관리가 필요한 중요한 처리를 하지 않는 데도 말이다.&lt;/p&gt;

&lt;p&gt;기존 앱들이 잘 되어 있었으면 괜찮지만, 메모리 누수가 다수 발견되어 해결하는 데 많은 고생을 하곤 했다.&lt;br /&gt;
Obj-C도 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 환경을 사용하는 데 무리가 없는데, 굳이 메모리 누수를 만들어 내며 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;를 고수했는지 알 수가 없다.
(물론, &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 환경도 메모리 누수 방지를 위한 처리가 필요하지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt;는 더 꼼꼼하게 처리해야 한다.)&lt;br /&gt;
실제로 생산성도 떨어지고 메모리 누수와 버그도 발생하기 쉬워 &lt;strong&gt;비효율적&lt;/strong&gt;이었다.
(그래서 어떤 앱의 경우, 나에게 기회가 생겨 추후 유지보수를 위해 한 달의 시간을 투자해 Swift 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 환경으로 완전 포팅했다. 😂)&lt;/p&gt;

&lt;h2 id=&quot;앞으로는-웬만하면-무조건-arc&quot;&gt;앞으로는 웬만하면 무조건 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;그렇게 기존처럼 오늘도 메모리 누수 지옥을 해결하기 위해 많은 노력을 했다. (아직 남아있을 수도 있겠지만 😤)&lt;br /&gt;
앞으로 가능하면 새 프로젝트는 무조건 (정말 특별한 경우를 제외하곤) &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 환경으로 시작하려 한다.
메모리 누수 지옥을 해결하는 노력을 다른 데 쓰면 앱의 퀄리티를 더 높일 수 있을 것 같다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 3: 안드로이드 테스트는 힘들어 (feat. 파편화)</title><link href="https://jamesu.dev/posts/2020/05/14/til-3-android-testing-is-so-hard-feat-fragmentation/" rel="alternate" type="text/html" title="TIL 3: 안드로이드 테스트는 힘들어 (feat. 파편화)" /><published>2020-05-14T00:00:00+09:00</published><updated>2020-05-14T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/14/til-3-android-testing-is-so-hard-feat-fragmentation</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/14/til-3-android-testing-is-so-hard-feat-fragmentation/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이미 알고 있었던 것처럼 &lt;strong&gt;안드로이드의 파편화&lt;/strong&gt;는 끔찍했다.&lt;br /&gt;
하지만, 더 끔찍했던 것은 &lt;strong&gt;앱의 완성도&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt; 방지는 기본 중의 기본! (특히, 모바일 개발에서는 필수!)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SwipeRefreshLayout&lt;/code&gt; 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;가 연속으로 중첩된 경우,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nestedScrollingEnabled&lt;/code&gt; 옵션을 이용해 새로고침 동작이 중복되지 않도록 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;끔찍한-안드로이드의-파편화&quot;&gt;끔찍한 안드로이드의 파편화&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;assets/figure_1.jpg&quot; alt=&quot;Figure 1&quot; /&gt;
&lt;em&gt;내 표정도 이와 같다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;오늘 하루 날을 잡아 사내에서 개발한 안드로이드 앱 하나의 테스트를 진행하고 이슈를 처리하는 시간을 가졌다.
내가 직접 만든 앱이었다면, 알 수 없는 자신감으로 버그가 적을 것이라 예상할 수 있지만, 인수인계 받은 앱이라 정상 작동을 확신하지 못했다.
그렇게 OS 버전과 제조사를 고려해 Android 4.4 ~ 9.0 버전과 삼성 및 LG의 핸드폰을 대상으로 테스트를 진행했다.&lt;/p&gt;

&lt;p&gt;버전 이슈가 없길 희망했지만, 결과는 희망을 배신했다.&lt;br /&gt;
아무래도 이렇게 다양한 버전과 기기를 대상으로 테스트한 것은 처음이라 그런지 OS 버전에 따른 이슈가 존재했다.
특히, 4.4 버전의 이슈가 대부분이었고, 다행히 다른 버전에서는 큰 이슈가 없었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/figure_2.png&quot; alt=&quot;Figure 2&quot; title=&quot;Figure 2&quot; /&gt;
&lt;em&gt;안드로이드 OS 버전 파편화&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;사전에 최소 OS 버전을 무엇으로 할 지 조사를 한 결과, &lt;strong&gt;약 95% 이상을 커버하려면 4.4 버전(KitKat) 이상&lt;/strong&gt;이어야 했다.
물론, 4.4 버전을 사용하는 사용자는 매우 적을 것이라 생각하지만, 업무 도메인 특성상 옛날 폰을 사용하는 사용자가 존재할 가능성이 있기 때문이다.
아무튼 4.4 버전에서만 발생하는 이슈가 많아 5.0 버전부터 지원할 지 논의할 예정이다.&lt;/p&gt;

&lt;p&gt;이처럼 안드로이드는 iOS에 비해 버전 파편화와 기기 파편화가 심해서 예상했던 결과였다.
(기기 파편화를 고려해 여러 제조사를 테스트하고 싶었으나 해당 테스트 센터에서는 준비된 기기가 없었다.)&lt;/p&gt;

&lt;p&gt;정말 끔찍했던 것은 파편화의 문제가 아니라 &lt;strong&gt;앱의 완성도&lt;/strong&gt;였다.&lt;br /&gt;
개인적으로 앱을 개발할 때 앱의 완성도를 신경쓰는 편이다.
iOS 버전과의 &lt;strong&gt;동작의 일관성&lt;/strong&gt;을 당연하고, 특별한 경우를 제외하고는 &lt;strong&gt;UI의 일관성&lt;/strong&gt;도 유지하려고 한다.
그런데 여기서 당연하게 되어야 할 동작의 일관성에 버그가 꽤나 발견됐다.
앞서 개발 후 보유한 기기를 토대로 테스트를 진행했는데도 버그가 존재한 채로 출시한 것이다.
요구사항에 대한 기본적인 테스트도 진행하지 않으며 개발한 것이 눈에 보였다.
(중요한 요구사항 일부가 정상적으로 반영되지 않았다.)&lt;/p&gt;

&lt;p&gt;이제는 인수인계를 받은 앱이기 때문에 지금부터 발생하는 버그는 내 책임이 될 것이다.&lt;br /&gt;
나도 누군가에게 내가 받은 느낌을 주지 않도록 앱의 완성도를 끌어 올리는데 더욱 노력해야겠다. 💪&lt;/p&gt;

&lt;h2 id=&quot;npe-방지를-놓치는-실수는-하지-말자&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt; 방지를 놓치는 실수는 하지 말자&lt;/h2&gt;

&lt;p&gt;앞서 말한 버그 중 하나는 개발자라면 누구나 맞이한 적이 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Null Pointer Exception (이하 NPE)&lt;/code&gt;였다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt;는 런타임 에러 중 하나로, &lt;strong&gt;메모리에 할당되지 않은 주소에 접근을 시도한 경우 발생하는 예외&lt;/strong&gt;이다.&lt;br /&gt;
서버 개발이라면, 공통 예외 처리를 통해 서버가 종료되지 않고 에러를 반환하는 식의 처리가 가능하다.
하지만, &lt;strong&gt;모바일 개발에서는 예외 처리를 놓치면 앱이 강제 종료(Crash)&lt;/strong&gt;되기 때문에 매우 치명적이다.
사용하던 앱이 갑자기 알 수 없이 꺼진다면 누구라도 쓰고 싶지 않을 것이다.
그래서 서버 개발에서도 중요하겠지만, 특히 모바일 개발에서 예외 처리는 너무 중요한 부분이다.&lt;/p&gt;

&lt;p&gt;그 중에서도 &lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt;는 놓치기 쉬운 예외이다.&lt;br /&gt;
너무나 당연하게 주소에 값이 할당되어 있다고 생각하고 문법을 작성하면, 어느 순간 맞이할 수 있을 것이다.
개발자가 예상할 수 있는 예외는 해당 부분에 예외 처리를 하면 되지만,
&lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt;는 기본 문법의 실수로 발생하는 예외이기 때문에 더욱 주의가 필요하다.&lt;/p&gt;

&lt;p&gt;위에서 발생한 버그는 앱에서 로그인한 후에 처음으로 맞이하는 화면에서 간헐적으로 발생하던 버그이다.
나라도 로그인하자마자 앱이 꺼진다면 어이가 없을 것이다.
기존에 발견되지 않은 이유는 기기와 OS 버전에 따라 발생했던 버그라 우연히 발견되지 않았다.
역시나 안드로이드는 파편화에 대한 테스트 진행이 필수인 것 같다.&lt;/p&gt;

&lt;p&gt;앞으로 나도 더 꼼꼼하게 놓치지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;NPE&lt;/code&gt; 예외 처리를 해야겠다.
(욕먹기 싫다면 🙄)&lt;/p&gt;

&lt;h2 id=&quot;새로고침-동작이-엉뚱한-부분에서-시작되는-경우&quot;&gt;새로고침 동작이 엉뚱한 부분에서 시작되는 경우&lt;/h2&gt;

&lt;p&gt;발견한 또 다른 버그는 UI 이슈였다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;를 사용할 때, &lt;strong&gt;당겨서 새로고침&lt;/strong&gt; 동작을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;SwipeRefreshLayout&lt;/code&gt;를 사용했다.
그런데, &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt; 안의 항목 내부에도 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;를 사용해서 중첩된 구조였다.
새로고침 동작은 가장 외부에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;를 당겨서 수행하고 싶었지만,
저 아래로 스크롤한 후에 항목 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;를 당기는 경우에도 새로고침 동작이 수행되는 것이었다.&lt;/p&gt;

&lt;p&gt;그래서 알아본 결과, 항목 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;nestedScrollingEnabled&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정하면
외부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;에 대해서만 새로고침 동작이 작동하게 된다.&lt;/p&gt;

&lt;p&gt;참고로 해당 옵션은 &lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt;에서도 설정할 수 있지만, 4.4 버전을 지원하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt;이 아닌 코드로 설정해야 한다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;recyclerView.setNestedScrollingEnabled(false)&lt;/code&gt;와 같이 말이다.&lt;/p&gt;

&lt;p&gt;iOS 개발이 메인이지만, 안드로이드 개발 경험도 점점 쌓이고 있어 재밌는 것 같다. 😂&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="test" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 2: 팀 간 의사소통의 중요성</title><link href="https://jamesu.dev/posts/2020/05/13/til-2-importance-of-communication-between-teams/" rel="alternate" type="text/html" title="TIL 2: 팀 간 의사소통의 중요성" /><published>2020-05-13T00:00:00+09:00</published><updated>2020-05-13T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/13/til-2-importance-of-communication-between-teams</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/13/til-2-importance-of-communication-between-teams/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;팀 간 의사소통의 핵심은 &lt;strong&gt;서로를 위한 배려&lt;/strong&gt;이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;당연하지만-쉽지-않은-의사소통&quot;&gt;당연하지만 쉽지 않은 의사소통&lt;/h2&gt;

&lt;p&gt;다수의 팀으로 이루어진 회사에서 팀 간 의사소통은 당연하고 중요하지만 원하는 대로 이뤄지지 않는 경우가 많다.
회식을 하면 종종 타 팀과의 의사소통에 대한 불만을 듣는다.
겉으로 보기에 사이가 친하고 의사소통에 문제가 없어 보이는 멤버들 간에도 앙금이 쌓여 있어 불만을 토로 하는 것을 보면,
그런 사이에서도 일적인 의사소통은 정말 힘들 수 있다는 생각이 든다.
그래서 일 자체가 아닌 의사소통으로 인해 스트레스가 쌓이는 것을 보면 안타깝다는 생각도 든다.&lt;/p&gt;

&lt;p&gt;나의 경우에는 위 사례에서의 멤버가 앙금이 쌓여 있는 대상과 의사소통을 할 때, 특별히 까다롭지도 답답하지도 어렵지도 않다는 느낌을 받았다.
더불어 물론 의사소통에 의한 스트레스도 받고 있지 않다.
오히려 나와 일하는 것이 좋다는 이야기도 들어, 그런 이야기를 들을 때마다 뿌듯함이 함께한다.&lt;/p&gt;

&lt;h2 id=&quot;의사소통의-핵심&quot;&gt;의사소통의 핵심?&lt;/h2&gt;

&lt;p&gt;그렇다면, 나와 의사소통에 어려움을 겪고 있는 멤버와의 차이점은 무엇일까?&lt;br /&gt;
개인적으로 생각하기엔 좋은 의사소통의 핵심은 &lt;strong&gt;서로를 위한 배려&lt;/strong&gt;라고 생각한다.&lt;/p&gt;

&lt;p&gt;이것도 어찌 보면 당연하지만 제대로 실천되고 있지 않아 어려움을 겪는 사람들이 많다고 생각한다.
업무에 대한 이야기 함에 있어 상대방을 배려해 어느 정도 책임을 나눠 가지고(책임을 전가하지 않고),
어느 정도 의견을 수용하려 하고(항상 내가 옳다는 생각을 버리고),
어느 정도 서로의 역할을 이해하면(역할에 따라 앎의 정도가 다르다는 것을 이해하면),
서로 간의 신뢰감도 쌓이고 업무적으로 더 친밀해진다는 것을 느낄 수 있다.
그런 관계가 되고 나면, 팀 간 의사소통으로 인해 발생하는 스트레스도 없고 업무도 잘 처리되는 선순환이 이뤄지는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;앞으로도 이런 마음가짐을 토대로 팀 간 의사소통에 대해 긍정적으로 생각하고 실천하도록 하자.&lt;br /&gt;
지금까지 나도 모르게 의사소통을 잘 해왔다는 생각에 마음이 매우 뿌듯한 하루였다. 🙂&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="idea" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 1: Today I Learned 기록 시작</title><link href="https://jamesu.dev/posts/2020/05/12/til-1-starting-today-i-learned/" rel="alternate" type="text/html" title="TIL 1: Today I Learned 기록 시작" /><published>2020-05-12T00:00:00+09:00</published><updated>2020-05-12T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/12/til-1-starting-today-i-learned</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/12/til-1-starting-today-i-learned/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;매일 TIL을 작성해 &lt;code class=&quot;highlighter-rouge&quot;&gt;일일 배움&lt;/code&gt;을 실천하고 성장하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;til이란&quot;&gt;TIL이란?&lt;/h2&gt;

&lt;p&gt;TIL은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Today I Learned&lt;/code&gt;의 약자로, &lt;strong&gt;오늘 배운 것&lt;/strong&gt;을 뜻하는 말이다.&lt;/p&gt;

&lt;p&gt;블로그를 작성하는 개발자라면 많이 들어보기도 했을 것이고, GitHub에 잔디를 심기 위해 매일 TIL을 작성함으로써 일일 커밋을 실천하는 사람도 있을 것이다.
또한, 까먹지 않기 위해 기록하고 정리하는 용도로 사용하는 사람도 있고, 꾸준함을 습관화하기 위해 작성하는 사람도 있을 것이다.&lt;/p&gt;

&lt;p&gt;이처럼 TIL의 용도는 무궁무진하다.&lt;br /&gt;
그렇다면, 나는 어떻게 사용할 것인가?&lt;/p&gt;

&lt;h2 id=&quot;내-til의-목적&quot;&gt;내 TIL의 목적&lt;/h2&gt;

&lt;p&gt;나의 경우, GitHub에 잔디를 심기 위해 이 블로그에 글을 꾸준히 올리고 싶었지만,
잘못된 정보를 전달하지 않고 글의 완성도를 높이기 위해 조사를 더 하다보면, 글 하나를 작성하는 데에도 많은 시간이 소요된다.
그렇게 긴 글을 작성하는 것도 아닌데 말이다. (글 솜씨가 부족한 것도 있다.)&lt;br /&gt;
그 대신, 알고리즘 문제를 꾸준히 풀어 GitHub에 올리는 것으로 잔디 심기를 하고 있다.
그래서 사실 나의 TIL은 일일 커밋을 통한 잔디 심기가 목적이 아니다.&lt;/p&gt;

&lt;p&gt;일일 커밋도 좋지만, 그보다는 내 스스로의 성장을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;일일 배움&lt;/code&gt;을 실천하고 싶다.&lt;br /&gt;
그 주제가 무엇이 되든 상관 없다.
배울 수 있는 것이라면, 개발 주제가 될 수도 있고, 어떤 생각이 될 수도 있고, 책에서 얻은 배움이 될 수도 있다.
매일 글을 쓰면서 나도 모르게 늘어나는 글 솜씨도 배움이 될 수 있다. (간절)&lt;br /&gt;
그렇게 매일 더 나아지는 내가 되길 바라며 TIL을 작성하고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;앞으로의-방향&quot;&gt;앞으로의 방향&lt;/h2&gt;

&lt;p&gt;TIL을 시작하면, 가장 중요한 부분은 &lt;strong&gt;꾸준함&lt;/strong&gt;이라 생각된다.&lt;br /&gt;
현재 블로그의 경우, CLI로 직접 배포하며 글을 올리고 있어 귀차니즘이 심하고,
계속 언급한 글 솜씨의 부족으로 내용을 생각하고 정리하는 데 많은 시간이 소요된다. (변명 아닌 변명)&lt;br /&gt;
그래서 TIL만큼은 기존의 글을 쓰듯이 매우 정성들여 쓰기 보다는 가볍더라도 &lt;strong&gt;기록하는 것에 초점을 맞추고자 한다&lt;/strong&gt;.
(물론, 어느 정도 이해는 할 수 있도록 작성해야 한다. 술 먹고 작성할 때 조심 😅)&lt;/p&gt;

&lt;p&gt;미래의 내가 실망하고 후회하지 않도록 꾸준히 작성해보자. 🙂&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="idea" /><summary type="html">TL;DR</summary></entry><entry><title type="html">백준 문제 풀이: 15649 - N과 M (1)</title><link href="https://jamesu.dev/posts/2020/04/13/baekjoon-problem-solving-15649/" rel="alternate" type="text/html" title="백준 문제 풀이: 15649 - N과 M (1)" /><published>2020-04-13T00:00:00+09:00</published><updated>2020-04-13T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/04/13/baekjoon-problem-solving-15649</id><content type="html" xml:base="https://jamesu.dev/posts/2020/04/13/baekjoon-problem-solving-15649/">&lt;p&gt;&lt;img src=&quot;assets/baekjoon_15649.png&quot; alt=&quot;15649 - N과 M (1)&quot; title=&quot;15649 - N과 M (1)&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제-파악&quot;&gt;문제 파악&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15649&quot; target=&quot;_blank&quot;&gt;N과 M (1) 문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;N까지의 자연수 중 중복 없이 M개를 고른 수열은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/순열&quot; target=&quot;_blank&quot;&gt;순열(Permutation)&lt;/a&gt;을 뜻한다.
먼저 순열의 정의를 파악하고, 문제를 풀이하도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;문제-풀이&quot;&gt;문제 풀이&lt;/h2&gt;

&lt;p&gt;사실 이 문제는 &lt;strong&gt;Python&lt;/strong&gt;을 사용한다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;itertools.permutations()&lt;/code&gt; 함수를 이용해 답을 바로 구할 수 있다.&lt;br /&gt;
Python에서 손쉽게 순열, 조합 등을 구할 수 있는 함수를 제공하기 때문이다.&lt;br /&gt;
하지만, 그것은 &lt;strong&gt;백트래킹&lt;/strong&gt;을 연습하고자 하는 이 문제의 의도와 다르므로 사용하지 않도록 한다.&lt;/p&gt;

&lt;p&gt;위에서 언급한 &lt;a href=&quot;https://ko.wikipedia.org/wiki/퇴각검색&quot; target=&quot;_blank&quot;&gt;백트래킹(Backtracking, 퇴각검색)&lt;/a&gt;이란 무엇일까?&lt;br /&gt;
백트래킹은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/깊이_우선_탐색&quot; target=&quot;_blank&quot;&gt;DFS(Depth-First Search, 깊이 우선 탐색)&lt;/a&gt;의 방식을 기반으로,
&lt;strong&gt;불필요한 경우를 배제하며 원하는 해답에 도달할 때까지 탐색하는 전략&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/figure_1.png&quot; alt=&quot;Figure 1&quot; title=&quot;Figure 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같이, DFS를 기반으로 두고 있기 때문에 &lt;a href=&quot;https://ko.wikipedia.org/wiki/스택&quot; target=&quot;_blank&quot;&gt;스택(Stack)&lt;/a&gt;을 이용해 퇴각을 하며
다음 탐색을 진행하기 때문에 백트래킹(또는 퇴각검색)이라 불린다.&lt;/p&gt;

&lt;p&gt;백트래킹은 기본적으로는 모든 경우의 수를 탐색한다는 &lt;a href=&quot;https://namu.wiki/w/%EB%B8%8C%EB%A3%A8%ED%8A%B8%20%ED%8F%AC%EC%8A%A4&quot; target=&quot;_blank&quot;&gt;브루트 포스(Brute Force)&lt;/a&gt; 전략을 취하지만,
처리 속도를 향상시키기 위한 &lt;strong&gt;가지치기(Pruning)&lt;/strong&gt;가 중요한 역할을 한다.&lt;br /&gt;
나무에서 불필요한 가지를 제거하듯이 백트래킹에서 가지치기를 잘 할수록 불필요한 경우가 제거되어 처리 속도가 많이 향상된다.&lt;/p&gt;

&lt;p&gt;다시 문제로 돌아와서, 이 문제는 &lt;strong&gt;숫자를 선택하는 경우의 수로 이루어진 트리&lt;/strong&gt;로 볼 수 있다.&lt;br /&gt;
반복적으로 숫자를 선택해 M개까지 골라 수열을 완성하는 것이 목표이다.&lt;br /&gt;
따라서, 백트래킹을 적용해 불필요한 경우를 배제한 모든 경우의 수를 고려할 수 있다.&lt;/p&gt;

&lt;p&gt;숫자를 선택할 때는 1부터 N까지의 자연수 중 선택해야 하므로, 차례대로 선택하는 경우의 수가 있을 것이다.&lt;br /&gt;
이때, 반드시 &lt;strong&gt;해당 경우의 수를 스택에 추가(Push)하고, 동작(여기서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt; 함수)이 끝난 후에는 다시 스택에서 빼내는 작업(Pop)이 필요하다&lt;/strong&gt;.
그래야 정상적으로 이전의 상황으로 돌아올 수 있기 때문이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그렇게 선택을 반복했을 때, 그 선택한 경우의 수가 M이 되면 모두 고른 것이 되므로 해답이 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;하지만, 위와 같이 &lt;strong&gt;항상 1부터 N까지의 자연수를 모두 순회하면, 이미 선택한 숫자를 또 선택해가며 시간을 낭비하게 된다&lt;/strong&gt;.&lt;br /&gt;
그래서 이미 선택한 숫자를 다시 선택하려 하면 배제하는 방식으로 &lt;strong&gt;가지치기&lt;/strong&gt;를 할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;ps-함수-호출-스택-이용하기&quot;&gt;P.S. 함수 호출 스택 이용하기&lt;/h3&gt;

&lt;p&gt;여기서는 DFS를 위한 스택으로 Python의 List를 이용했다.&lt;br /&gt;
이와 다른 방식으로 다음과 같이 &lt;strong&gt;순수하게 함수만을 이용해서 구현할 수도 있다&lt;/strong&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([])&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이것이 가능한 이유는 &lt;strong&gt;함수의 호출 방식이 스택의 동작 방식과 일치&lt;/strong&gt;하기 때문이다.&lt;br /&gt;
함수가 호출되면, 함수의 호출 스택에 함수를 위한 요소들이 차례대로 쌓이고(Push),&lt;br /&gt;
함수가 종료되면, 함수의 호출 스택에서 해당 요소들이 제거(Pop)된다.&lt;br /&gt;
결국, 함수가 호출되기 전의 상태로 돌아가게 된다.&lt;/p&gt;

&lt;p&gt;이처럼 함수 호출 스택을 사용해서 스택을 이용하는 다른 알고리즘에 적용해 보는 것도 도움이 될 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-소스&quot;&gt;풀이 소스&lt;/h2&gt;

&lt;p&gt;문제 풀이 환경: Python 3.7&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>jamesujeon</name></author><category term="problem-solving" /><category term="baekjoon" /><category term="backtracking" /><category term="dfs" /><category term="python" /><summary type="html"></summary></entry><entry><title type="html">백준 문제 풀이: 4673 - 셀프 넘버</title><link href="https://jamesu.dev/posts/2020/04/05/baekjoon-problem-solving-4673/" rel="alternate" type="text/html" title="백준 문제 풀이: 4673 - 셀프 넘버" /><published>2020-04-05T00:00:00+09:00</published><updated>2020-04-05T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/04/05/baekjoon-problem-solving-4673</id><content type="html" xml:base="https://jamesu.dev/posts/2020/04/05/baekjoon-problem-solving-4673/">&lt;p&gt;&lt;img src=&quot;assets/baekjoon_4673.png&quot; alt=&quot;4673 - 셀프 넘버&quot; title=&quot;4673 - 셀프 넘버&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제-파악&quot;&gt;문제 파악&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/4673&quot; target=&quot;_blank&quot;&gt;셀프 넘버 문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;생성자의 개수와 관계없이 생성자가 없는 숫자가 셀프 넘버이므로, 생성자의 존재 여부만 확인하면 된다.&lt;br /&gt;
생성자의 존재 여부를 어떻게 해결할 것인지에 초점을 맞춘다.&lt;/p&gt;

&lt;h2 id=&quot;문제-풀이&quot;&gt;문제 풀이&lt;/h2&gt;

&lt;p&gt;여러 숫자에 대해 각 숫자가 생성자를 가지는지 아닌지 판단하는 것은 매우 많은 계산량을 필요로 하게 된다.&lt;br /&gt;
그렇다면, 반대로 생각해보자.&lt;/p&gt;

&lt;p&gt;특정 숫자를 생성자로 가지는 다음 숫자는 문제에서 정의한 &lt;code class=&quot;highlighter-rouge&quot;&gt;d(n)&lt;/code&gt; 함수를 통해 쉽게 구할 수 있을 것이다.&lt;br /&gt;
또한, 반복적으로 해당 함수를 적용하면, 계속해서 해당 생성자를 가지는 숫자들을 구할 수 있다.&lt;br /&gt;
&lt;strong&gt;셀프 넘버의 정의가 생성자가 없는 숫자이므로, 생성자를 가지는 숫자들은 셀프 넘버가 아닌 것이다&lt;/strong&gt;.&lt;br /&gt;
위의 방법으로 셀프 넘버가 아닌 숫자들을 빠르고 쉽게 구할 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 이 문제처럼 범위가 주어진다면, 소수를 구할 때 체를 걸러내는 방식인 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4&quot; target=&quot;_blank&quot;&gt;에라토스테네스의 체(Sieve of Eratosthenes)&lt;/a&gt;의
원리를 적용하기에 적합하다.&lt;br /&gt;
주어진 범위에 대해 생성자로부터 &lt;strong&gt;셀프 넘버가 아닌 숫자들을 걸러낸다면, 결국에는 셀프 넘버만 남게 된다&lt;/strong&gt;.&lt;br /&gt;
(에라토스테네스의 체로 소수를 구하는 방법은 &lt;a href=&quot;https://jamesu.dev/posts/2019/12/23/codeforces-problem-solving-230b-t-primes&quot; target=&quot;_blank&quot;&gt;Codeforces 문제 풀이: 230B - T-primes&lt;/a&gt; 포스트에서 확인할 수 있다.)&lt;/p&gt;

&lt;p&gt;위와 같은 원리로, 10001개 요소를 가지는 배열 &lt;code class=&quot;highlighter-rouge&quot;&gt;sn&lt;/code&gt;을 정의하고, 셀프 넘버만 남기도록 체를 거른다.&lt;br /&gt;
그리고 다시 순회하며 셀프 넘버만 출력하면 된다.&lt;br /&gt;
참고로 10001개 요소를 선언한 이유는 0을 제외한 숫자 맵핑을 쉽게 하기 위해서다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-소스&quot;&gt;풀이 소스&lt;/h2&gt;

&lt;p&gt;문제 풀이 환경: Python 3.7&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;dn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>jamesujeon</name></author><category term="problem-solving" /><category term="baekjoon" /><category term="sieve-of-eratosthenes" /><category term="python" /><summary type="html"></summary></entry></feed>