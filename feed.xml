<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko_KR"><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://jamesu.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jamesu.dev/" rel="alternate" type="text/html" hreflang="ko_KR" /><updated>2021-01-01T22:21:26+09:00</updated><id>https://jamesu.dev/</id><title type="html">Jamesu Devlog</title><subtitle>Dev Blog by James Minsu Jeon</subtitle><author><name>jamesujeon</name><email>jamesujeon@gmail.com</email></author><entry><title type="html">TIL 20: 2020년 회고</title><link href="https://jamesu.dev/posts/2021/01/01/til-20-2020-retrospective/" rel="alternate" type="text/html" title="TIL 20: 2020년 회고" /><published>2021-01-01T00:00:00+09:00</published><updated>2021-01-01T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2021/01/01/til-20-2020-retrospective</id><content type="html" xml:base="https://jamesu.dev/posts/2021/01/01/til-20-2020-retrospective/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;GitHub 연속 일일 커밋은 나름 성공적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;232&lt;/code&gt;일째 진행중이다.&lt;/li&gt;
  &lt;li&gt;TIL은 &lt;code class=&quot;highlighter-rouge&quot;&gt;개발 일기&lt;/code&gt;로 생각하고 많이 분발해 작성하자.&lt;/li&gt;
  &lt;li&gt;작년의 프로젝트는 모두 만족스럽고 재밌었다.
    &lt;ul&gt;
      &lt;li&gt;Objective-C to Swift 포팅&lt;/li&gt;
      &lt;li&gt;iOS/Android 앱 디자인 리뉴얼&lt;/li&gt;
      &lt;li&gt;사내 iOS 공통 라이브러리 개발&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;올해의 프로젝트에 iOS 개발 트렌드를 반영하자.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RxSwift&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;iOS 디자인 패턴: &lt;code class=&quot;highlighter-rouge&quot;&gt;MVVM&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CI/CD&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;iOS에 집중해 &lt;code class=&quot;highlighter-rouge&quot;&gt;깊이가 깊은 iOS 개발자&lt;/code&gt;가 되자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;today-i-committed&quot;&gt;Today I Committed&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;assets/github_2020_contributions.png&quot; alt=&quot;GitHub 2020 Contributions&quot; width=&quot;100%&quot; /&gt;
&lt;em&gt;GitHub Contributions in 2020&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;GitHub를 사용하면서 개인적인 성취감을 위해 일일 커밋을 4월 초부터 시작했다.
그러다 4월 11일에 한 번 구멍이 생기고, 5월 13일에 한 번 더 구멍이 생기면서…
2020년의 연속 일일 커밋은 아쉽게 &lt;strong&gt;232일째&lt;/strong&gt;로 끝이 났다.&lt;/p&gt;

&lt;p&gt;일일 커밋은 하루 한 줄이라도 코드를 작성하면서 그 감을 잃지 않고 꾸준함을 유지하려는 목적으로 시작했다.
약속이 있는 날, 바쁜 날 등처럼 일일 커밋을 하기 힘든 날에도 계속 신경써서 연속 일일 커밋을 유지한 나에게 작은 칭찬을 하고 싶다.&lt;/p&gt;

&lt;p&gt;이제는 일일 커밋이 매일 떠오를 정도로 습관이 몸에 배어 2021년에도 실수하지만 않으면 연속 일일 커밋을 할 수 있을 것 같다.
2021년에는 4월 11일, 5월 13일과 같은 구멍이 발생하지 않도록 조심하며, 꾸준히 신기록을 갱신하고 싶다.&lt;br /&gt;
2021년의 Contributions에는 초록색으로 가득차길 바라며, 오늘도 나는 커밋 잔디를 심는다… 🌱&lt;/p&gt;

&lt;h2 id=&quot;today-i-learned-but&quot;&gt;Today I Learned, but…&lt;/h2&gt;

&lt;p&gt;5월에는 &lt;strong&gt;TIL&lt;/strong&gt;에 관심이 생기면서 TIL을 일일 커밋 겸 작성하려고 했으나… 매일 글을 쓰는 게 나에게는 너무 어려웠다.
&lt;strong&gt;일일 배움&lt;/strong&gt;이라는 마음가짐으로 TIL을 시작했기에 무엇이라도 배운 것이 있을 때 그것에 대해 작성했고, 생각보다 소재 고갈이 잦았다.
(물론, 배운 것이 있었지만 글로 안 쓴 것도 많다… 🤔)&lt;/p&gt;

&lt;p&gt;TIL 작성은 &lt;strong&gt;6월 이후부터 12월이 되기 전까지는 전무&lt;/strong&gt;했고, 일일 커밋은 주로 원래 하던 문제 풀이를 통해 진행했다.
아무래도 글쓰기가 익숙하지 않아서 그런지 (많이 어렵지 않은) 문제 풀이가 글쓰기보다는 쉬웠다.
글을 고치는 게 잦아서 글쓰기에 많은 시간이 들어가고, 새로운 문장을 생각해내는 것도 어려웠다.&lt;/p&gt;

&lt;p&gt;사실 내 TIL의 원래 취지는 &lt;strong&gt;기록&lt;/strong&gt;하는 것에 초점이 맞춰 있는 &lt;strong&gt;개발 일기&lt;/strong&gt;에 가깝다.
그 초점에 맞추지 않고 TIL을 작성하다 보니 배가 산으로 간 것 같다.
“정성 가득 길게 글을 쓰는 것보다는 무엇을 배웠는 지를 기록하는 것이 목표이므로 앞으로는 그 부담을 덜고 작성했으면 좋겠다.”
라고 2021년의 나에게 말하고 싶다. 🙄&lt;/p&gt;

&lt;h2 id=&quot;today-i-worked&quot;&gt;Today I Worked&lt;/h2&gt;

&lt;p&gt;재작년에는 서버와 웹 프론트엔드 유지보수가 주 업무였다면, 작년은 모바일 업무에 집중할 수 있었던 해였다.
모바일 개발자로 입사했기에 모바일 업무에 집중하는 것이 맞지만 어찌저찌 다른 업무를 맡았어서 모바일 업무만 하고 싶다고 강력 어필 했었다.
결과적으로 4분기에 서버를 잠시 했었지만, 모바일에 집중 할 수 있어 좋았다.&lt;/p&gt;

&lt;p&gt;작년의 대표적인 모바일 성과로는 &lt;strong&gt;Objective-C to Swift 포팅, iOS/Android 앱 디자인 리뉴얼, 사내 iOS 공통 라이브러리 개발&lt;/strong&gt;이 있다.
Swift 포팅은 자진해서 진행했던 프로젝트이고, 앱 디자인 리뉴얼은 전면 개편이라 내부 구조도 바꿔가며 손이 많이 갔다.
마지막으로 사내 iOS 공통 라이브러리 개발은 자주 쓰는 뷰나 기능 등을 모아 라이브러리로 만드는 작업으로 현재 진행형이다.&lt;/p&gt;

&lt;h3 id=&quot;objective-c-to-swift-포팅&quot;&gt;Objective-C to Swift 포팅&lt;/h3&gt;

&lt;p&gt;사내에 Objective-C로 되어 있는 앱들이 있어 유지보수가 매우 힘들었고, 그리하여 효율화를 위해 자진해서 Swift 포팅 프로젝트를 추진했다.
앱 하나에 대해서만 진행했으며, 기존 앱에 요구사항이 덜 적용된 부분도 있어 전체적으로 품질 향상의 효과도 있었다.
디자인 개선도 같이 진행해서 Swift 포팅을 하며 새로 만드는 것이 오히려 더 수월했다.
야근을 많이 해서 힘들었지만, &lt;strong&gt;두 언어의 차이를 느끼며 여러가지를 비교할 기회가 되어 아주 만족스러웠던 프로젝트였다&lt;/strong&gt;. 🙂&lt;/p&gt;

&lt;h3 id=&quot;iosandroid-앱-디자인-리뉴얼&quot;&gt;iOS/Android 앱 디자인 리뉴얼&lt;/h3&gt;

&lt;p&gt;디자인 리뉴얼은 앱 하나의 디자인 전체를 개편하는 작업이라 거의 모든 소스를 건드려야 했다.
그 과정에서 내부 구조도 많이 개선시키면서 두 플랫폼의 요구사항이 맞지 않는 것을 맞춰가는 작업까지 진행했다.
iOS와 안드로이드 모두를 맡다 보니 힘들었지만,
&lt;strong&gt;내부 구조를 분석하면서 어떻게 하면 효율적으로 구조화 할 수 있을지 두 플랫폼 모두에 대해 고민 할 수 있어 큰 경험이 됐다&lt;/strong&gt;.
그래도 앞으로는 주 업무는 iOS만 하고 싶다. 🤔&lt;/p&gt;

&lt;h3 id=&quot;사내-ios-공통-라이브러리-개발&quot;&gt;사내 iOS 공통 라이브러리 개발&lt;/h3&gt;

&lt;p&gt;사내 iOS 공통 라이브러리 개발은 새 앱을 개발하거나 기존 앱을 개선할 때 효율적으로 프로젝트를 진행하고자 추진한 프로젝트다.
앞으로 만들 새 앱에 대한 일관성 있는 디자인과 기능을 적용하고자 디자인 팀과 빈번하게 의사소통하며 요구사항을 정리했다.
커스터마이징도 가능하게 만들면서 공통적인 부분만 추출해 구현하고자 노력했다.
&lt;strong&gt;앱을 만드는 관점과 달리 라이브러리를 만드는 관점에서 구현을 하다보니 두 관점이 많이 다르다는 것을 느낄 수 있었다&lt;/strong&gt;. 🙂&lt;/p&gt;

&lt;h2 id=&quot;tomorrow-i-will-learn&quot;&gt;Tomorrow I will Learn&lt;/h2&gt;

&lt;p&gt;여러 개발 분야의 트렌드는 모두 빠르게 바뀌고 발전하고 있다.
모바일 개발 트렌드 또한 새로운 것이 생겨나고 기존 것이 발전하고 있는데,
트렌드를 계속 접하고는 있으나 지금까지 제대로 프로젝트에 반영한 적은 없다.&lt;/p&gt;

&lt;p&gt;최근에 공부하던 모바일 개발 트렌드 중 특히 iOS 개발 트렌드는 &lt;strong&gt;RxSwift, iOS 디자인 패턴, CI/CD&lt;/strong&gt; 등이 있다.
나열한 목록들이 현재 가장 관심이 많고 적용하고 싶은 개발 트렌드에 해당한다.&lt;/p&gt;

&lt;h3 id=&quot;rxswift&quot;&gt;RxSwift&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxSwift&quot; target=&quot;_blank&quot;&gt;RxSwift&lt;/a&gt;는 비동기 및 이벤트 기반 프로그래밍을 지향하는
&lt;a href=&quot;http://reactivex.io/&quot; target=&quot;_blank&quot;&gt;ReactiveX&lt;/a&gt; 프로젝트의 Swift 버전이다.&lt;br /&gt;
ReactiveX 컨셉으로 프로그래밍을 하면 가독성, 안정성, 효율성 등과 같은
다양한 이점을 얻을 수 있어 개인적으로 가장 적용하고 싶은 트렌드이다.
RxSwift를 틈틈이 공부하고 있어,
&lt;strong&gt;추후 사내 iOS 공통 라이브러리에 Rx 버전을 구현하는 것과 실제 프로젝트에 적용하는 것을 생각하고 있다&lt;/strong&gt;.
굉장히 재밌는 프로그래밍이 될 것 같아 기대가 된다. 🔥&lt;/p&gt;

&lt;h3 id=&quot;ios-디자인-패턴&quot;&gt;iOS 디자인 패턴&lt;/h3&gt;

&lt;p&gt;iOS 디자인 패턴 또는 iOS 아키텍쳐라고도 불리는 이것은 앱의 코드 구성을 의미한다.
iOS의 기본은 MVC로 되어 있고,
이는 비효율적인 코드 구성을 낳기 때문에 사람들은 새로운 구성을 개발해 내었다.&lt;/p&gt;

&lt;p&gt;MVVM, MVP, VIPER, RIBs, ReactorKit 등과 같이 다양한 디자인 패턴이 있지만,
이 중에서 나는 RxSwift와 함께 자주 언급되는 패턴인 &lt;strong&gt;MVVM&lt;/strong&gt;을 프로젝트에 적용하고 싶다.
안드로이드에서도 RxJava, RxKotlin과 함께 자주 사용되는 패턴인 만큼 기본이 되는 패턴이라 생각한다.
일단, &lt;strong&gt;MVVM을 실제 프로젝트에 적용 해보는 방향으로 하고 나머지 패턴은 개인적으로 공부하며 고민해봐야겠다&lt;/strong&gt;. 🤔&lt;/p&gt;

&lt;h3 id=&quot;cicd&quot;&gt;CI/CD&lt;/h3&gt;

&lt;p&gt;CI/CD는 Continuous Integration(지속적 통합)을 뜻하는 CI와
Continuous Delivery(지속적 제공) 또는 Continuous Deployment(지속적 배포)를 뜻하는 CD를 합쳐 부르는 말이다.
이 프로세스는 서버와 웹 프론트엔드 개발에서는 자주 사용하는 프로세스로 모바일 개발에서도 적용한 사례가 꽤 있을 것이다.&lt;/p&gt;

&lt;p&gt;현재 사내 앱 배포는 모든 과정을 사람이 수동으로 진행하고 있어 여러모로 비효율적일 수 있다.
CI/CD를 적용하면 이런 과정이 자동화되므로,
수동 배포 과정에서 발생하는 실수도 방지하고, 배포 과정에 크게 신경을 쓸 필요 없이 그 결과에 대해서만 대응하면 된다.
주 업무가 되는 것에 일을 집중할 수 있으므로 생산성 향상이 기대될 수 있다.&lt;/p&gt;

&lt;p&gt;사내 앱 배포에 CI/CD를 적용하는 것이 적합한 것인가에 대해서는 더 고민할 필요가 있긴 하다.
앞으로 개발자가 더 많아지고, 유닛 테스트가 잘 작성되어진다면, 그 효율성은 체감할 수 있는 수준이 될 것 같다.
&lt;strong&gt;기회가 된다면, &lt;a href=&quot;https://fastlane.tools/&quot; target=&quot;_blank&quot;&gt;Fastlane&lt;/a&gt;을 iOS와 안드로이드 모두에 적용해 프로세스를 개선하고 싶다&lt;/strong&gt;. 🤔&lt;/p&gt;

&lt;h2 id=&quot;tomorrow-i-will-become&quot;&gt;Tomorrow I will Become&lt;/h2&gt;

&lt;p&gt;2021년 올해는 개인적으로 많은 성장을 바라는 해이다.&lt;br /&gt;
작년에는 모바일 개발에 집중할 수 있었지만, 트렌드를 적용 못하고 사내 앱 개편에만 신경을 썼었다.&lt;br /&gt;
올해는 트렌드도 적용해가며 iOS 개발의 깊이를 더해가고 싶다.&lt;/p&gt;

&lt;p&gt;올해의 가장 큰 목표는 &lt;strong&gt;깊이가 깊은 iOS 개발자&lt;/strong&gt;가 되는 것이다.&lt;br /&gt;
그 깊이의 기준은 정할 수 없지만, 스스로 열심히 했다고 생각이 들 정도로 노력을 해보자. 🔥&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="idea" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 19: Simple-Jekyll-Search 오픈 소스 기여</title><link href="https://jamesu.dev/posts/2020/12/26/til-19-contribution-for-simple-jekyll-search-oss/" rel="alternate" type="text/html" title="TIL 19: Simple-Jekyll-Search 오픈 소스 기여" /><published>2020-12-26T00:00:00+09:00</published><updated>2020-12-26T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/12/26/til-19-contribution-for-simple-jekyll-search-oss</id><content type="html" xml:base="https://jamesu.dev/posts/2020/12/26/til-19-contribution-for-simple-jekyll-search-oss/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;이 블로그에 검색 기능을 넣고 싶어서
&lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search&quot; target=&quot;_blank&quot;&gt;Simple-Jekyll-Search&lt;/a&gt;
라이브러리를 적용하려 했다.&lt;/li&gt;
  &lt;li&gt;버그를 발견해 수정해서 Simple-Jekyll-Search 라이브러리에
&lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search/pull/162&quot; target=&quot;_blank&quot;&gt;PR&lt;/a&gt;을 보냈다.&lt;/li&gt;
  &lt;li&gt;Merge되면 좋겠다.&lt;/li&gt;
  &lt;li&gt;오픈 소스 분석은 은근 재밌다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;버그-발견-수정-도전-그리고-pr&quot;&gt;버그 발견, 수정 도전, 그리고 PR&lt;/h2&gt;

&lt;p&gt;이 블로그를 만들고 사용하면서 가장 큰 문제 중 하나는 원하는 글을 검색할 수 없다는 것이었다.&lt;br /&gt;
그래서 검색 기능을 넣고자 알아보던 중에
&lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search&quot; target=&quot;_blank&quot;&gt;Simple-Jekyll-Search&lt;/a&gt;를
알게 되었고, 그것이 내가 원하는 검색 기능에 어느 정도 부합하다는 생각이 들어 적용 하기로 마음 먹었다.&lt;br /&gt;
그리고 이 라이브러리의 예제 수준으로만 검색 기능을 적용하기에는 원하는 퀄리티가 나오지 않아 커스터마이징 작업도 진행하기로 했다.&lt;/p&gt;

&lt;p&gt;그렇게 작업을 진행하던 중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;exclude&lt;/code&gt; 옵션을 적용해보다가 전혀 작동하지 않는 현상을 발견했다.&lt;br /&gt;
그것을 보고 갑자기 삘(?)을 받아 처음에는 의도치 않았지만, 해당 라이브러리의 소스를 분석하기 시작했다.&lt;/p&gt;

&lt;p&gt;해당 소스의 주 언어는 JavaScript였고, 많이 사용해 본 경험이 없어 낯설었지만 재밌겠다는 생각에 분석을 진행했다.&lt;br /&gt;
검색해가며 소스 분석을 하다 보니 아주 치명적인 버그를 발견할 수 있었다.&lt;br /&gt;
검색 기능 관련 객체를 생성하는 코드에서 전달한 &lt;code class=&quot;highlighter-rouge&quot;&gt;exclude&lt;/code&gt; 옵션을 세팅하지 않는 것이었다.&lt;/p&gt;

&lt;p&gt;다행히 소스의 덩치가 크지 않아 분석하는 것이 크게 어렵지 않았고,
버그를 수정해서 Simple-Jekyll-Search 라이브러리에
&lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search/pull/162&quot; target=&quot;_blank&quot;&gt;Pull Request(PR)&lt;/a&gt;을 보냈다.&lt;br /&gt;
최근까지도 Merge된 흔적이 있는 것을 보니 활동하고 있는 프로젝트라 생각이 들었다.&lt;br /&gt;
부디 나의 PR을 받아 들여 Merge되면 좋을 것 같다. 🥺&lt;/p&gt;

&lt;h2 id=&quot;오픈-소스-기여&quot;&gt;오픈 소스 기여&lt;/h2&gt;

&lt;p&gt;Open Source Software(이하 OSS)에 기여하는 것은 항상 어려운 일이라고만 생각이 들었는데, 생각보다 쉬운 일이었다.
물론, 시작은 쉽지만 Merge 되는 것은 어려울 수 있다.&lt;br /&gt;
시작이 반이라는 말처럼 일단 시작하는 것에 큰 의의를 두려고 한다.&lt;/p&gt;

&lt;p&gt;또한, 나와 다른 사고와 스타일을 가진 개발자의 코드를 보니 신기하고 재밌었다.&lt;br /&gt;
내 코드도 GitHub을 통해 공개되기도 하니 코드 퀄리티에 더 신경 써야겠다는 생각이 재차 들었다.&lt;/p&gt;

&lt;p&gt;OSS들을 보다 보면 생각보다 작은 덩치도 많고, 그런 프로젝트는 진입 장벽도 높지 않으니 자주 시도해보는 것이 좋을 것 같다.
이것이 쌓이면, 큰 프로젝트에 기여하는 것도 불가능한 일은 아닐 것 같다.&lt;br /&gt;
기여한 OSS가 많아지면 그 뿌듯함도 점점 쌓여가지 않을까? 🙂&lt;/p&gt;

&lt;h2 id=&quot;20201227-내용-추가&quot;&gt;2020.12.27 내용 추가&lt;/h2&gt;

&lt;p&gt;해당 &lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search/pull/162&quot; target=&quot;_blank&quot;&gt;PR&lt;/a&gt;의
Merge가 받아들여졌다!&lt;br /&gt;
매우 뿌듯하고, 해당 프로젝트를 더 발전시키고 싶은 욕심이 생긴다.&lt;br /&gt;
불편했던 기능이 하나 있는데… 그것도 바꿔볼까? 🔥&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="oss" /><category term="jekyll" /><category term="javascript" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 18: 자잘한 안드로이드 UI 팁들 2</title><link href="https://jamesu.dev/posts/2020/06/15/til-18-some-android-ui-tips-2/" rel="alternate" type="text/html" title="TIL 18: 자잘한 안드로이드 UI 팁들 2" /><published>2020-06-15T00:00:00+09:00</published><updated>2020-06-15T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/06/15/til-18-some-android-ui-tips-2</id><content type="html" xml:base="https://jamesu.dev/posts/2020/06/15/til-18-some-android-ui-tips-2/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;코드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 매개변수로 전달한 인자에 따른 주의사항&lt;/li&gt;
  &lt;li&gt;코드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;이 적용되지 않는 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt; 자식으로 스크롤 뷰 형태의 뷰가 있을 때, 이중 스크롤을 방지하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;클릭을 빠르게 두 번 했을 때, 이벤트가 두 번 발생하는 것을 방지하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;코드로 높이, 너비 등과 같은 값을 설정하는 경우&lt;/li&gt;
  &lt;li&gt;뷰의 변환을 지속적으로 감지하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt; 사용 시, 고정 높이가 적용되지 않는 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ellipsize&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt;로 적용하는 경우 주의사항&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;자잘한-안드로이드-ui-팁들-2&quot;&gt;자잘한 안드로이드 UI 팁들 2&lt;/h2&gt;

&lt;p&gt;유지보수를 하며 추가적으로 간단하게 정리했던 팁들이다.&lt;br /&gt;
앞서 작성했던 팁들은 바로 이전 글에서 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;1-코드로-inflate-할-때-root-매개변수로-전달한-인자에-따른-동작-구분&quot;&gt;1. 코드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 매개변수로 전달한 인자에 따른 동작 구분&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 매개변수에 부모 뷰를 전달하면, 부모 뷰에 &lt;code class=&quot;highlighter-rouge&quot;&gt;addView()&lt;/code&gt; 메소드를 호출해 자식으로 추가되는 효과가 난다.
반대로, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;을 전달하면 추가가 되지 않으므로 직접 추가를 해줘야 한다.&lt;/p&gt;

&lt;p&gt;때에 따라 부모 뷰를 전달할 필요가 없기도 한다.&lt;br /&gt;
그런데 두 경우에 반환한 뷰가 서로 달라 주의가 필요하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;부모 뷰를 전달한 경우: &lt;strong&gt;부모 뷰&lt;/strong&gt;가 반환된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;을 전달한 경우: &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 된 뷰&lt;/strong&gt;가 반환된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-코드로-inflate-할-때-margin이-적용되지-않는-경우&quot;&gt;2. 코드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;이 적용되지 않는 경우&lt;/h3&gt;

&lt;p&gt;분명히 &lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt; 레이아웃에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;을 적용했는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 한 경우 실제로 적용되지 않는 것을 확인할 수 있다.
이 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 매개변수에 부모 뷰를 전달했는지 안했는지에 따라 달라진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;부모 뷰를 전달한 경우: &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;이 정상적으로 적용&lt;/strong&gt;된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;을 전달한 경우: &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;이 적용되지 않아 &lt;strong&gt;코드로 직접 적용해야 한다&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때 부모가 주어지면 &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;을 판단할 수 있으나, 없다면 판단할 수 없어 발생하는 문제인 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;3-scrollview-자식으로-스크롤-뷰-형태의-뷰가-있을-때-이중-스크롤을-방지하고-싶은-경우&quot;&gt;3. &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt; 자식으로 스크롤 뷰 형태의 뷰가 있을 때, 이중 스크롤을 방지하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;스크롤 뷰 형태의 뷰라 하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt; 등 스크롤이 생길 수 있는 뷰를 말한다.
해당 뷰를 이용해서 데이터를 표현했지만, 높이를 고정시키고 싶을 때가 있을 것이다.
그런데 부모로 &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt;를 그냥 사용하면, 고정 높이가 적용되지 않을 수가 있다.&lt;/p&gt;

&lt;p&gt;부모에 해당하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt; 대신 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NestedScrollView&lt;/code&gt;를 사용&lt;/strong&gt;한다.&lt;br /&gt;
자식으로 스크롤 뷰 형태의 뷰를 가지면, 그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;NestedScrollView&lt;/code&gt;를 사용하는 것이 속 편할 것 같다.&lt;br /&gt;
아니면 항상 &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt; 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;NestedScrollView&lt;/code&gt;를 사용하는 것도…&lt;/p&gt;

&lt;h3 id=&quot;4-클릭을-빠르게-두-번-했을-때-이벤트가-두-번-발생하는-것을-방지하고-싶은-경우&quot;&gt;4. 클릭을 빠르게 두 번 했을 때, 이벤트가 두 번 발생하는 것을 방지하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;클릭 이벤트에서 마지막으로 클릭한 시간을 기록했다가 현재 시간과 비교해 간격을 줄 수 있다.&lt;/p&gt;

&lt;p&gt;아래와 같은 코드를 클릭 이벤트에 넣어 구현이 가능하다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SystemClock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;elapsedRealtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mLastClickTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mLastClickTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SystemClock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;elapsedRealtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;하지만, 이것도 정말 빠르게 두 번 누르면 같은 현상이 발생한다…&lt;br /&gt;
추가적으로 다른 조치가 필요할 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;5-코드로-높이-너비-등과-같은-값을-설정하는-경우&quot;&gt;5. 코드로 높이, 너비 등과 같은 값을 설정하는 경우&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;코드로 해당 값들을 설정하는 메소드는 대부분 &lt;code class=&quot;highlighter-rouge&quot;&gt;px&lt;/code&gt; 값을 수치로 전달 받는다.&lt;/strong&gt;&lt;br /&gt;
만약, 디자인을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;dp&lt;/code&gt; 값 설정이 필요하다면, 반드시 변환해서 전달하도록 한다.&lt;/p&gt;

&lt;p&gt;일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;dpToPx()&lt;/code&gt;와 같은 유틸 메소드를 만들어 사용하곤 한다.&lt;/p&gt;

&lt;h3 id=&quot;6-뷰의-변환을-지속적으로-감지하고-싶은-경우&quot;&gt;6. 뷰의 변환을 지속적으로 감지하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;뷰의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewTreeObserver&lt;/code&gt;를 얻어 &lt;code class=&quot;highlighter-rouge&quot;&gt;OnGlobalLayoutListener&lt;/code&gt;를 설정하면 지속적 감지가 가능하다.
하지만, 매우 자주 호출되므로 주의가 필요하다.&lt;/p&gt;

&lt;p&gt;일회성 동작이라면, &lt;code class=&quot;highlighter-rouge&quot;&gt;GlobalLayout&lt;/code&gt; 이벤트에서 해당 리스너를 지우도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;7-constraintlayout-사용-시-고정-높이가-적용되지-않는-경우&quot;&gt;7. &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt; 사용 시, 고정 높이가 적용되지 않는 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_constrainedHeight&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;로 설정한다.&lt;/p&gt;

&lt;h3 id=&quot;8-ellipsize를-middle로-적용하는-경우-주의사항&quot;&gt;8. &lt;code class=&quot;highlighter-rouge&quot;&gt;ellipsize&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt;로 적용하는 경우 주의사항&lt;/h3&gt;

&lt;p&gt;줄 수를 2줄 이상으로 허용하는 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;ellipsize&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt;이면 경우에 따라 크래시가 발생할 수 있다.
따라서 2줄 이상인 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt; 값을 사용하지 않고, &lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;와 같은 다른 값을 사용해야 한다.&lt;/p&gt;

&lt;p&gt;1줄인 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt; 값을 사용하는 것에 문제가 없다.&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 17: 자잘한 안드로이드 UI 팁들</title><link href="https://jamesu.dev/posts/2020/06/09/til-17-some-android-ui-tips/" rel="alternate" type="text/html" title="TIL 17: 자잘한 안드로이드 UI 팁들" /><published>2020-06-09T00:00:00+09:00</published><updated>2020-06-09T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/06/09/til-17-some-android-ui-tips</id><content type="html" xml:base="https://jamesu.dev/posts/2020/06/09/til-17-some-android-ui-tips/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt; 항목들이 서로 잘리지 않게 하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DrawerLayout&lt;/code&gt;로 사이드 화면을 열었을 때, 뒤의 컨텐츠 부분이 클릭되는 경우&lt;/li&gt;
  &lt;li&gt;버튼의 그림자를 제거하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;이미지를 너비는 꽉 채우되, 비율에 따라 높이를 동적으로 설정하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPager&lt;/code&gt;를 빠르게 스크롤 할 때, 흰 배경이 보이는 경우&lt;/li&gt;
  &lt;li&gt;상태바 높이를 얻고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bottom Sheet Dialog&lt;/code&gt;의 드래그 동작을 막고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EditText&lt;/code&gt; 내부 스크롤을 활성화하고 싶은 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;자잘한-안드로이드-ui-팁들&quot;&gt;자잘한 안드로이드 UI 팁들&lt;/h2&gt;

&lt;p&gt;안드로이드 개발을 하면서 느끼는 점은 iOS 개발도 불편한 부분이 많았지만, 안드로이드는 더 심한 것처럼 느껴진다.
정말 쉽게 처리될 것 같은 부분도 직접 해보면 편법인지 아닌지도 모르겠는 편법같은 처리를 해야 되는 부분도 있고 해서 참으로 힘들다.
그래서 이런 자잘한 처리들을 모아 라이브러리를 만들어 두고두고 쓰면 좋을 것 같다는 생각이 들었다.
언제 만들지는 모르지만…&lt;/p&gt;

&lt;h3 id=&quot;1-recyclerview-항목들이-서로-잘리지-않게-하고-싶은-경우&quot;&gt;1. &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt; 항목들이 서로 잘리지 않게 하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;clipChildren&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정한다.&lt;br /&gt;
그러면, 자식들이 서로 자르지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;2-drawerlayout로-사이드-화면을-열었을-때-뒤의-컨텐츠-부분이-클릭되는-경우&quot;&gt;2. &lt;code class=&quot;highlighter-rouge&quot;&gt;DrawerLayout&lt;/code&gt;로 사이드 화면을 열었을 때, 뒤의 컨텐츠 부분이 클릭되는 경우&lt;/h3&gt;

&lt;p&gt;사이드 화면의 레이아웃에 &lt;code class=&quot;highlighter-rouge&quot;&gt;clickable&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;focusable&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;로 설정한다.&lt;br /&gt;
사이드 화면이 클릭 가능하게 함으로써 막는다.&lt;/p&gt;

&lt;h3 id=&quot;3-버튼의-그림자를-제거하고-싶은-경우&quot;&gt;3. 버튼의 그림자를 제거하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stateListAnimator&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;@null&lt;/code&gt;로 설정한다.&lt;/p&gt;

&lt;h3 id=&quot;4-이미지를-너비는-꽉-채우되-비율에-따라-높이를-동적으로-설정하고-싶은-경우&quot;&gt;4. 이미지를 너비는 꽉 채우되, 비율에 따라 높이를 동적으로 설정하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adjustViewBounds&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;로, 너비를 &lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;로 설정한다.&lt;br /&gt;
반대의 경우는 너비와 높이를 바꿔 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;5-viewpager를-빠르게-스크롤-할-때-흰-배경이-보이는-경우&quot;&gt;5. &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPager&lt;/code&gt;를 빠르게 스크롤 할 때, 흰 배경이 보이는 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPager&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;offscreenPageLimit&lt;/code&gt;를 적절하게 설정해 페이지를 미리 로딩하도록 한다.&lt;br /&gt;
복잡한 뷰일수록 수치를 낮게 설정해야 과부하가 걸리지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;6-상태바-높이를-얻고-싶은-경우&quot;&gt;6. 상태바 높이를 얻고 싶은 경우&lt;/h3&gt;

&lt;p&gt;상태바 높이에 해당하는 리소스를 찾아내 구할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStatusBarHeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Resources&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getResources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resourceId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getIdentifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;status_bar_height&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;dimen&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;android&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resourceId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDimensionPixelSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resourceId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;7-bottom-sheet-dialog의-드래그-동작을-막고-싶은-경우&quot;&gt;7. &lt;code class=&quot;highlighter-rouge&quot;&gt;Bottom Sheet Dialog&lt;/code&gt;의 드래그 동작을 막고 싶은 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BottomSheetBehavior&lt;/code&gt;에 다음과 같은 콜백을 추가한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addBottomSheetCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BottomSheetBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;BottomSheetCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onStateChanged&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bottomSheet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BottomSheetBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;STATE_DRAGGING&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BottomSheetBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;STATE_EXPANDED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSlide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bottomSheet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slideOffset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;8-edittext-내부-스크롤을-활성화하고-싶은-경우&quot;&gt;8. &lt;code class=&quot;highlighter-rouge&quot;&gt;EditText&lt;/code&gt; 내부 스크롤을 활성화하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;다음과 같은 터치 리스너를 추가한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;editText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setOnTouchListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;editText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasFocus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestDisallowInterceptTouchEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MotionEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ACTION_MASK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MotionEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ACTION_SCROLL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestDisallowInterceptTouchEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 16: 레거시 시스템은 지옥</title><link href="https://jamesu.dev/posts/2020/06/05/til-16-legacy-system-is-hell/" rel="alternate" type="text/html" title="TIL 16: 레거시 시스템은 지옥" /><published>2020-06-05T00:00:00+09:00</published><updated>2020-06-05T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/06/05/til-16-legacy-system-is-hell</id><content type="html" xml:base="https://jamesu.dev/posts/2020/06/05/til-16-legacy-system-is-hell/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;레거시 시스템은 가능하면 빨리 개선해서 지옥을 맞이하지 않도록 하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;뉴저지-코볼cobol-사건으로-느껴지는-레거시-시스템의-폐해&quot;&gt;뉴저지 코볼(COBOL) 사건으로 느껴지는 레거시 시스템의 폐해&lt;/h2&gt;

&lt;p&gt;노마드 코더는 즐겨보는 유튜버 중 한명으로 다양한 프로그래밍 관련 이야기를 해준다.&lt;br /&gt;
가끔씩 재밌는 이슈도 이야기 해주는데, 이번에 들려준 이슈는 &lt;strong&gt;코볼(COBOL) 레거시 시스템에서 얻는 교훈&lt;/strong&gt;에 관한 것이었다.
(&lt;a href=&quot;https://youtu.be/LJ9TXkh9Xhk&quot; target=&quot;_blank&quot;&gt;유튜브 영상 링크&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;간단히 요약하자면,
미국 뉴저지 정부의 전산 시스템이 비교적 오래된 언어인 코볼로 이뤄져 있는 레거시 시스템인데, 개발자를 구할 수 없다는 것이다.
이번 코로나19 사태로 전산 시스템에 유래 없이 많은 사용자가 몰리게 되었고,
그것의 유지보수를 위해 코볼 개발자를 급하게 구하고 있지만 공급이 없어 애를 먹는 상황이다.&lt;/p&gt;

&lt;p&gt;오래된 언어답게 요즘 자주 사용하는 언어에 비하면 생산성도 떨어지고, 여러모로 단점이 많다.
이렇게 오랫동안 지속된 레거시 시스템은 진작에 시간을 두어 개편 작업을 해야 마땅한데 &lt;strong&gt;현업에서도 우선순위에서 밀리는 경우가 많다&lt;/strong&gt;.&lt;br /&gt;
이처럼 뉴저지 코볼 사건은 레거시 시스템이 낳은 안타까운 결과물 중 하나이다.&lt;/p&gt;

&lt;p&gt;비슷하게 (어디에나 존재할 수 있지만) 재직중인 회사에도 레거시 시스템이 존재한다.
그것의 구조적 한계로 인해 일부 유용한 개선도 못하고 있는 것이 보인다.&lt;br /&gt;
또한, 내가 맡고 있는 iOS 앱들도 불필요하게 Objective-C에 MRC 환경으로 되어 있다.
이런 환경일수록 더 디테일하게 다뤄야 하는데 그러지 못해 버그와 메모리 누수가 산발한다.&lt;/p&gt;

&lt;p&gt;뉴저지 코볼 사건처럼 나중에 후회하지 않으려면 &lt;strong&gt;일부 시간을 내서라도 구조, 환경 등의 개편을 진행해야 한다고 생각한다&lt;/strong&gt;.
그렇게 하나의 앱은 한달의 시간을 어떻게든 내어 Objective-C에서 Swift로 포팅을 진행했고, 여러모로 만족하고 있다.&lt;/p&gt;

&lt;p&gt;앞으로도 기회가 조금이라도 보이면, 기회를 만들어 기존 앱들의 포팅을 진행하거나 효율적인 구조로 개편하는 작업을 하고 싶다.
야근은 자제하면서 말이다.. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="idea" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 15: Notion은 유용해</title><link href="https://jamesu.dev/posts/2020/05/31/til-15-notion-is-useful/" rel="alternate" type="text/html" title="TIL 15: Notion은 유용해" /><published>2020-05-31T00:00:00+09:00</published><updated>2020-05-31T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/31/til-15-notion-is-useful</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/31/til-15-notion-is-useful/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.notion.so&quot; target=&quot;_blank&quot;&gt;Notion&lt;/a&gt; 툴은 개발자를 위한 &lt;strong&gt;메모 및 글 관리&lt;/strong&gt;에 유용하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개발자를-위한-메모-및-글-관리-툴&quot;&gt;개발자를 위한 메모 및 글 관리 툴&lt;/h2&gt;

&lt;p&gt;개발을 하다보면 Code Snippet, 유용한 링크, 메모 등을 빠르게 작성하고, 보관하고 싶을 것이다.&lt;br /&gt;
&lt;a href=&quot;https://www.notion.so&quot; target=&quot;_blank&quot;&gt;Notion&lt;/a&gt;을 사용하면, 그 욕구를 잘 해소할 수 있다.&lt;/p&gt;

&lt;p&gt;이전에는 맥북에 내장되어 있는 메모 앱을 자주 사용하곤 했는데, 내용이 필요할 때마다 애플 계정 동기화 또는 로그인이 필요했다.
그래서 어디서든 빠르게 접근할 수 있는 메모가 필요했고, 우연히 웹 툴인 Notion을 접하게 되었다.&lt;/p&gt;

&lt;p&gt;이걸 왜 이제 알았는지 모르겠다.&lt;br /&gt;
간단하고 편리하고 개발자가 쓰기 좋은 기능들도 꽤 있다.&lt;br /&gt;
게다가 디자인이 내 취향이다. 😀&lt;/p&gt;

&lt;p&gt;한 문단과 비슷한 블록이라는 단위로 작성 단위를 측정하고 있다.&lt;br /&gt;
그것과 업로드 용량 등 여러 요소에 따라 요금제가 달라진다.&lt;br /&gt;
기본적으로 무료로 제공되는 양도 괜찮기 때문에 일단 사용해보고 판단하길 바란다.&lt;/p&gt;

&lt;p&gt;홍보대사는 아니지만, 이런 유용한 툴을 나만 알고 싶지 않아서 공유한다.&lt;br /&gt;
그동안 모르고 있었다면, 나처럼 빠져들지도 모른다. 😍&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="tool" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 14: TimePicker 때문에 자바의 Reflection을 쓰게 되다…</title><link href="https://jamesu.dev/posts/2020/05/28/til-14-long-time-no-see-reflection-of-java-for-time-picker/" rel="alternate" type="text/html" title="TIL 14: TimePicker 때문에 자바의 Reflection을 쓰게 되다..." /><published>2020-05-28T00:00:00+09:00</published><updated>2020-05-28T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/28/til-14-long-time-no-see-reflection-of-java-for-time-picker</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/28/til-14-long-time-no-see-reflection-of-java-for-time-picker/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;기본으로 제공되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;를 커스텀하기 위해 자바의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;을 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;뭔가-제약이-많은-기본-timepicker&quot;&gt;뭔가 제약이 많은 기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;앱 개발을 하다 보면 디자인 요구사항을 위해 뷰를 커스텀 할 일이 많아진다.&lt;br /&gt;
그리고 다채로운 요구사항을 맞추다 보면, 커스텀하는 데 시간을 은근 빼았기곤 한다.&lt;/p&gt;

&lt;p&gt;이번에 회사에서 디자인 개선을 진행할 때는 일부 UI에 대해서는 시스템에서 제공하는 기본 UI를 사용하기로 해서 일을 많이 덜었다.
그래도 앱의 컨셉 컬러는 맞춰야 하니깐 기본 UI라도 그 컬러를 맞추고자 했다.&lt;/p&gt;

&lt;p&gt;그렇게 작업한 UI 중 하나가 기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;를 &lt;strong&gt;Spinner 모드&lt;/strong&gt;로 포함되어 있는 선의 색깔만 바꾸면 되는 것이었다.
당연히 5분도 안 걸릴 일이라 생각했고, 그것은 착오였다. ☠️&lt;/p&gt;

&lt;p&gt;기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 Spinner 모드는 XML을 통한 레이아웃에서만 설정할 수 있었고, 나는 코드를 통한 설정이 필요했다.
굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt; 하나 때문에 불필요한 레이아웃 파일을 하나 더 늘리기는 싫었고 코드를 통해 설정하고자 했지만,
관련 설정 메소드가 없었고 과거에 사용하던 특정한 Theme를 설정해야 Spinner 모드로 작동하는 것이었다.&lt;br /&gt;
일단, 여기서 한 번 이리저리 헤맸었다.&lt;/p&gt;

&lt;p&gt;두 번째로 스타일 설정을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;에 포함되어 있는 선의 색깔을 쉽게 바꿀 수 있는줄 알았다.
이것도 당연히 5분도 안 걸릴 일이라 생각했지만, 그것 또한 착오였다. ☠️&lt;/p&gt;

&lt;p&gt;일반적인 방법으로 Sinner 모드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 선(엄밀히 말하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt; 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberPicker&lt;/code&gt;의 선)에 접근하는 것은 불가능했다.
최후의 방법으로 자바의 API 중 하나인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;을 쓰게 되었다. 😂&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;을 쓰면 클래스 내부에 &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;인 멤버들에도 접근할 수 있고, 조작도 가능하다.
그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 내부 구조를 파악하고, 결국에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberPicker&lt;/code&gt;의 선의 색깔을 변경할 수 있었다.
웬만하면 쓸 일이 없는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;인데 이렇게 사용하니, 내가 까먹지 말라고 쓰게 해주는 것이구나 싶었다.&lt;/p&gt;

&lt;p&gt;기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 Spinner 모드도, 그 색깔을 변경하는 것도 자주 쓸만한 기능인데 왜 이렇게 꽁꽁 감싸 놓았는지 답답했었다.
그래도 ‘다 의도가 있겠지’라는 마음과 결국엔 해결했다는 것에 뿌듯함을 느낀다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="java" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 13: 안드로이드에서는 Image Asset Studio를 이용해 아이콘을 추가하자</title><link href="https://jamesu.dev/posts/2020/05/27/til-13-use-image-asset-studio-to-add-app-icon/" rel="alternate" type="text/html" title="TIL 13: 안드로이드에서는 Image Asset Studio를 이용해 아이콘을 추가하자" /><published>2020-05-27T00:00:00+09:00</published><updated>2020-05-27T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/27/til-13-use-image-asset-studio-to-add-app-icon</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/27/til-13-use-image-asset-studio-to-add-app-icon/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드에서 아이콘을 추가할 때,
Android Studio의 &lt;strong&gt;Image Asset Studio&lt;/strong&gt;를 이용하면 쉽게 &lt;strong&gt;여러 종류의 아이콘(적응형 및 레거시 아이콘 포함)&lt;/strong&gt;을 생성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;적응형-및-레거시-아이콘-추가를-위한-image-asset-studio&quot;&gt;적응형 및 레거시 아이콘 추가를 위한 Image Asset Studio&lt;/h2&gt;

&lt;p&gt;안드로이드 개발자라면 많은 사람들이 Android Studio를 사용할 것이다.&lt;br /&gt;
Android Studio는 앱 개발을 위한 많은 편리한 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;그 중 하나가 앱 개발을 위한 Asset을 손쉽게 추가하고 관리할 수 있도록 지원해준다는 것이다.
특히, 아이콘의 경우, &lt;strong&gt;안드로이드 OS 버전에 따라 사용하는 아이콘 모양이 상이&lt;/strong&gt;하기 때문에
직접 파편화에 대응해 Asset을 준비한다면 정말 손이 많이 가는 일이 될 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;이번에 회사에서 기존 앱의 전면 디자인 개선 작업을 하면서 앱 아이콘 또한 변경의 대상이었기 때문에 교체가 필요했다.
기존에 존재하던 앱 아이콘은 하나의 이미지로 여러 아이콘을 커버하도록 대충 되어 있었다.
그래서 싹 지우고, Android Studio에서 제공하는 &lt;strong&gt;Image Asset Studio&lt;/strong&gt;를 이용해 아이콘을 추가했더니
레거시까지 고려해 아름답게 여러 아이콘이 생성되어 한방에 해결할 수 있었다.&lt;/p&gt;

&lt;p&gt;더 궁금한 것이 있다면, &lt;a href=&quot;https://developer.android.com/studio/write/image-asset-studio#access&quot; target=&quot;_blank&quot;&gt;공식 안드로이드 개발자 문서&lt;/a&gt;에 잘 설명되어 있다.&lt;br /&gt;
Android Studio는 안드로이드 개발자에게 정말 축복같은 IDE인 것 같다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="android-studio" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 12: iOS에 Auto Layout이 있다면, Android에는 ConstraintLayout이 있다!</title><link href="https://jamesu.dev/posts/2020/05/25/til-12-android-constraint-layout-similar-to-ios-auto-layout/" rel="alternate" type="text/html" title="TIL 12: iOS에 Auto Layout이 있다면, Android에는 ConstraintLayout이 있다!" /><published>2020-05-25T00:00:00+09:00</published><updated>2020-05-25T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/25/til-12-android-constraint-layout-similar-to-ios-auto-layout</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/25/til-12-android-constraint-layout-similar-to-ios-auto-layout/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt;을 사용하면,&lt;br /&gt;
iOS의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Layout&lt;/code&gt; 컨셉으로 레이아웃을 구성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ios-개발자에게-반가운-안드로이드의-constraintlayout&quot;&gt;iOS 개발자에게 반가운 안드로이드의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;iOS 개발자라면 스토리보드를 사용하든 코드로 작성하든 &lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Layout&lt;/code&gt;을 이용해 뷰를 구성한 경험이 있을 것이다.
&lt;strong&gt;제약 조건(Constraint)&lt;/strong&gt;을 이렇게 저렇게 (잘) 걸어두면, &lt;strong&gt;화면의 변화에 따라 뷰가 자동으로 배치되고 크기가 변하게 할 수 있다&lt;/strong&gt;.
물론, 잘 설정한다는 가정이 필요하다.
잘못 설정하면 레이아웃이 엄청 깨지는 것을 경험할 수 있으므로, 제약 조건에 대한 이해가 확실해야 한다.&lt;/p&gt;

&lt;p&gt;아무튼 익숙해진다면, 아주 편리하게 뷰를 배치할 수 있을 것이다.
현재 회사에서 스토리보드를 사용하지 않고, 코드로만 뷰를 작성하는 프로젝트를 많이 하고 있기 때문에 정말 유용하게 사용하고 있다.
(&lt;del&gt;기존 레거시 코드는 좌표와 크기를 일일이 계산하면서 뷰를 작성해 유지보수가 지옥이다.&lt;/del&gt; 😇 &lt;del&gt;특히, 테이블 뷰 셀&lt;/del&gt;… ☠️)&lt;/p&gt;

&lt;p&gt;그러다 안드로이드 프로젝트를 진행하고 있는데, 옛날에 사용하던 &lt;code class=&quot;highlighter-rouge&quot;&gt;RelativeLayout&lt;/code&gt;은 뭔가 되게 어설프다.
원하는 레이아웃을 깔끔하게 구성하기 어려웠다.
그러던 중에 우연히 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt;을 알게 되었다.&lt;/p&gt;

&lt;p&gt;이름을 보자마자 익숙한 단어가 보였다.
&lt;strong&gt;Constraint&lt;/strong&gt;라는 단어가 이름에 붙은 것부터 &lt;strong&gt;제약 조건을 이용해 레이아웃을 구성&lt;/strong&gt;한다는 것을 유추할 수 있다.
그리고 직접 사용해보니 iOS의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Layout&lt;/code&gt;가 매우 유사했다!
아주 반가웠고, 그 컨셉에 빠르게 적응할 수 있었다.&lt;/p&gt;

&lt;p&gt;현재는 안드로이드 프로젝트에서도 유용하게 잘 사용하고 있다.&lt;br /&gt;
역시 익숙한 것이 좋은 것이여. 🙂&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 11: 다중 비동기 완료 처리를 위한 dispatch_group</title><link href="https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks/" rel="alternate" type="text/html" title="TIL 11: 다중 비동기 완료 처리를 위한 dispatch_group" /><published>2020-05-22T00:00:00+09:00</published><updated>2020-05-22T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;다중 비동기 처리가 완료되는 시점에 후속 처리를 하고 싶다면,&lt;br /&gt;
간단히 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 시리즈를 활용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모든-이미지-다운로드가-완료-됐을-때-로딩바-숨기기&quot;&gt;모든 이미지 다운로드가 완료 됐을 때, 로딩바 숨기기&lt;/h2&gt;

&lt;p&gt;동적으로 화면에 이미지를 보여주기 위해 다운로드가 필요할 때가 있다.
그때 많이 사용하는 방식은 각 이미지가 다운로드될 때마다 이미지 뷰에 표시하도록 해서
로딩바가 표시되더라도 각 이미지 뷰에 표시하도록 하는 것이다.
그런 처리는 일반적인 비동기 처리로 손쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만, 이번에 새로운 요구사항이 생겼다.
모든 이미지가 다운로드될 때까지 중앙에 로딩바를 표시하고,
모두 완료되고 나서 로딩바를 숨긴 후 다른 동작을 할 수 있도록 처리하는 것이다.
이것을 위해서는 &lt;strong&gt;각 비동기 처리(이미지 다운로드)가 완료되는 시점을 알아야 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;iOS에서 비동기 처리를 위한 방법으로 크게 두 가지가 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Operation&lt;/code&gt; 시리즈와 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 시리즈이다.
이번에는 간단하게 모든 이미지 다운로드가 완료됐을 때 로딩바를 숨기면 되므로, 비교적 단순한 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 시리즈를 이용했다.&lt;/p&gt;

&lt;p&gt;그 중에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 시리즈를 이용하면, 각 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 작업들을 &lt;strong&gt;그룹화&lt;/strong&gt;하고
완료되는 시점에 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt; 함수에 정의한 동작을 수행하도록 할 수 있다.&lt;/p&gt;

&lt;p&gt;이것도 한 번 시간을 내어 글로 정리해야겠다.&lt;br /&gt;
정말 정리할 글이 많다… 🤪&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><category term="gcd" /><summary type="html">TL;DR</summary></entry></feed>