<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko_KR"><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://jamesu.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jamesu.dev/" rel="alternate" type="text/html" hreflang="ko_KR" /><updated>2020-07-20T00:17:22+09:00</updated><id>https://jamesu.dev/</id><title type="html">Jamesu Devlog</title><subtitle>Dev Blog by James Minsu Jeon</subtitle><author><name>jamesujeon</name><email>jamesujeon@gmail.com</email></author><entry><title type="html">TIL 18: 자잘한 안드로이드 UI 팁들 2</title><link href="https://jamesu.dev/posts/2020/06/15/til-18-some-android-ui-tips-2/" rel="alternate" type="text/html" title="TIL 18: 자잘한 안드로이드 UI 팁들 2" /><published>2020-06-15T00:00:00+09:00</published><updated>2020-06-15T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/06/15/til-18-some-android-ui-tips-2</id><content type="html" xml:base="https://jamesu.dev/posts/2020/06/15/til-18-some-android-ui-tips-2/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;코드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 매개변수로 전달한 인자에 따른 주의사항&lt;/li&gt;
  &lt;li&gt;코드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;이 적용되지 않는 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt; 자식으로 스크롤 뷰 형태의 뷰가 있을 때, 이중 스크롤을 방지하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;클릭을 빠르게 두 번 했을 때, 이벤트가 두 번 발생하는 것을 방지하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;코드로 높이, 너비 등과 같은 값을 설정하는 경우&lt;/li&gt;
  &lt;li&gt;뷰의 변환을 지속적으로 감지하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt; 사용 시, 고정 높이가 적용되지 않는 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ellipsize&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt;로 적용하는 경우 주의사항&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;자잘한-안드로이드-ui-팁들-2&quot;&gt;자잘한 안드로이드 UI 팁들 2&lt;/h2&gt;

&lt;p&gt;유지보수를 하며 추가적으로 간단하게 정리했던 팁들이다.&lt;br /&gt;
앞서 작성했던 팁들은 바로 이전 글에서 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;1-코드로-inflate-할-때-root-매개변수로-전달한-인자에-따른-동작-구분&quot;&gt;1. 코드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 매개변수로 전달한 인자에 따른 동작 구분&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 매개변수에 부모 뷰를 전달하면, 부모 뷰에 &lt;code class=&quot;highlighter-rouge&quot;&gt;addView()&lt;/code&gt; 메소드를 호출해 자식으로 추가되는 효과가 난다.
반대로, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;을 전달하면 추가가 되지 않으므로 직접 추가를 해줘야 한다.&lt;/p&gt;

&lt;p&gt;때에 따라 부모 뷰를 전달할 필요가 없기도 한다.&lt;br /&gt;
그런데 두 경우에 반환한 뷰가 서로 달라 주의가 필요하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;부모 뷰를 전달한 경우: &lt;strong&gt;부모 뷰&lt;/strong&gt;가 반환된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;을 전달한 경우: &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 된 뷰&lt;/strong&gt;가 반환된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-코드로-inflate-할-때-margin이-적용되지-않는-경우&quot;&gt;2. 코드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;이 적용되지 않는 경우&lt;/h3&gt;

&lt;p&gt;분명히 &lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt; 레이아웃에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;을 적용했는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 한 경우 실제로 적용되지 않는 것을 확인할 수 있다.
이 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 매개변수에 부모 뷰를 전달했는지 안했는지에 따라 달라진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;부모 뷰를 전달한 경우: &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;이 정상적으로 적용&lt;/strong&gt;된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;을 전달한 경우: &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;이 적용되지 않아 &lt;strong&gt;코드로 직접 적용해야 한다&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt; 할 때 부모가 주어지면 &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;을 판단할 수 있으나, 없다면 판단할 수 없어 발생하는 문제인 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;3-scrollview-자식으로-스크롤-뷰-형태의-뷰가-있을-때-이중-스크롤을-방지하고-싶은-경우&quot;&gt;3. &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt; 자식으로 스크롤 뷰 형태의 뷰가 있을 때, 이중 스크롤을 방지하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;스크롤 뷰 형태의 뷰라 하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt; 등 스크롤이 생길 수 있는 뷰를 말한다.
해당 뷰를 이용해서 데이터를 표현했지만, 높이를 고정시키고 싶을 때가 있을 것이다.
그런데 부모로 &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt;를 그냥 사용하면, 고정 높이가 적용되지 않을 수가 있다.&lt;/p&gt;

&lt;p&gt;부모에 해당하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt; 대신 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NestedScrollView&lt;/code&gt;를 사용&lt;/strong&gt;한다.&lt;br /&gt;
자식으로 스크롤 뷰 형태의 뷰를 가지면, 그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;NestedScrollView&lt;/code&gt;를 사용하는 것이 속 편할 것 같다.&lt;br /&gt;
아니면 항상 &lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollView&lt;/code&gt; 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;NestedScrollView&lt;/code&gt;를 사용하는 것도…&lt;/p&gt;

&lt;h3 id=&quot;4-클릭을-빠르게-두-번-했을-때-이벤트가-두-번-발생하는-것을-방지하고-싶은-경우&quot;&gt;4. 클릭을 빠르게 두 번 했을 때, 이벤트가 두 번 발생하는 것을 방지하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;클릭 이벤트에서 마지막으로 클릭한 시간을 기록했다가 현재 시간과 비교해 간격을 줄 수 있다.&lt;/p&gt;

&lt;p&gt;아래와 같은 코드를 클릭 이벤트에 넣어 구현이 가능하다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SystemClock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;elapsedRealtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mLastClickTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mLastClickTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SystemClock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;elapsedRealtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;하지만, 이것도 정말 빠르게 두 번 누르면 같은 현상이 발생한다…&lt;br /&gt;
추가적으로 다른 조치가 필요할 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;5-코드로-높이-너비-등과-같은-값을-설정하는-경우&quot;&gt;5. 코드로 높이, 너비 등과 같은 값을 설정하는 경우&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;코드로 해당 값들을 설정하는 메소드는 대부분 &lt;code class=&quot;highlighter-rouge&quot;&gt;px&lt;/code&gt; 값을 수치로 전달 받는다.&lt;/strong&gt;&lt;br /&gt;
만약, 디자인을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;dp&lt;/code&gt; 값 설정이 필요하다면, 반드시 변환해서 전달하도록 한다.&lt;/p&gt;

&lt;p&gt;일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;dpToPx()&lt;/code&gt;와 같은 유틸 메소드를 만들어 사용하곤 한다.&lt;/p&gt;

&lt;h3 id=&quot;6-뷰의-변환을-지속적으로-감지하고-싶은-경우&quot;&gt;6. 뷰의 변환을 지속적으로 감지하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;뷰의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewTreeObserver&lt;/code&gt;를 얻어 &lt;code class=&quot;highlighter-rouge&quot;&gt;OnGlobalLayoutListener&lt;/code&gt;를 설정하면 지속적 감지가 가능하다.
하지만, 매우 자주 호출되므로 주의가 필요하다.&lt;/p&gt;

&lt;p&gt;일회성 동작이라면, &lt;code class=&quot;highlighter-rouge&quot;&gt;GlobalLayout&lt;/code&gt; 이벤트에서 해당 리스너를 지우도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;7-constraintlayout-사용-시-고정-높이가-적용되지-않는-경우&quot;&gt;7. &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt; 사용 시, 고정 높이가 적용되지 않는 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_constrainedHeight&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;로 설정한다.&lt;/p&gt;

&lt;h3 id=&quot;8-ellipsize를-middle로-적용하는-경우-주의사항&quot;&gt;8. &lt;code class=&quot;highlighter-rouge&quot;&gt;ellipsize&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt;로 적용하는 경우 주의사항&lt;/h3&gt;

&lt;p&gt;줄 수를 2줄 이상으로 허용하는 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;ellipsize&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt;이면 경우에 따라 크래시가 발생할 수 있다.
따라서 2줄 이상인 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt; 값을 사용하지 않고, &lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;와 같은 다른 값을 사용해야 한다.&lt;/p&gt;

&lt;p&gt;1줄인 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;middle&lt;/code&gt; 값을 사용하는 것에 문제가 없다.&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 17: 자잘한 안드로이드 UI 팁들</title><link href="https://jamesu.dev/posts/2020/06/09/til-17-some-android-ui-tips/" rel="alternate" type="text/html" title="TIL 17: 자잘한 안드로이드 UI 팁들" /><published>2020-06-09T00:00:00+09:00</published><updated>2020-06-09T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/06/09/til-17-some-android-ui-tips</id><content type="html" xml:base="https://jamesu.dev/posts/2020/06/09/til-17-some-android-ui-tips/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt; 항목들이 서로 잘리지 않게 하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DrawerLayout&lt;/code&gt;로 사이드 화면을 열었을 때, 뒤의 컨텐츠 부분이 클릭되는 경우&lt;/li&gt;
  &lt;li&gt;버튼의 그림자를 제거하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;이미지를 너비는 꽉 채우되, 비율에 따라 높이를 동적으로 설정하고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPager&lt;/code&gt;를 빠르게 스크롤 할 때, 흰 배경이 보이는 경우&lt;/li&gt;
  &lt;li&gt;상태바 높이를 얻고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bottom Sheet Dialog&lt;/code&gt;의 드래그 동작을 막고 싶은 경우&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EditText&lt;/code&gt; 내부 스크롤을 활성화하고 싶은 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;자잘한-안드로이드-ui-팁들&quot;&gt;자잘한 안드로이드 UI 팁들&lt;/h2&gt;

&lt;p&gt;안드로이드 개발을 하면서 느끼는 점은 iOS 개발도 불편한 부분이 많았지만, 안드로이드는 더 심한 것처럼 느껴진다.
정말 쉽게 처리될 것 같은 부분도 직접 해보면 편법인지 아닌지도 모르겠는 편법같은 처리를 해야 되는 부분도 있고 해서 참으로 힘들다.
그래서 이런 자잘한 처리들을 모아 라이브러리를 만들어 두고두고 쓰면 좋을 것 같다는 생각이 들었다.
언제 만들지는 모르지만…&lt;/p&gt;

&lt;h3 id=&quot;1-recyclerview-항목들이-서로-잘리지-않게-하고-싶은-경우&quot;&gt;1. &lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt; 항목들이 서로 잘리지 않게 하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RecyclerView&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;clipChildren&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정한다.&lt;br /&gt;
그러면, 자식들이 서로 자르지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;2-drawerlayout로-사이드-화면을-열었을-때-뒤의-컨텐츠-부분이-클릭되는-경우&quot;&gt;2. &lt;code class=&quot;highlighter-rouge&quot;&gt;DrawerLayout&lt;/code&gt;로 사이드 화면을 열었을 때, 뒤의 컨텐츠 부분이 클릭되는 경우&lt;/h3&gt;

&lt;p&gt;사이드 화면의 레이아웃에 &lt;code class=&quot;highlighter-rouge&quot;&gt;clickable&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;focusable&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;로 설정한다.&lt;br /&gt;
사이드 화면이 클릭 가능하게 함으로써 막는다.&lt;/p&gt;

&lt;h3 id=&quot;3-버튼의-그림자를-제거하고-싶은-경우&quot;&gt;3. 버튼의 그림자를 제거하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stateListAnimator&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;@null&lt;/code&gt;로 설정한다.&lt;/p&gt;

&lt;h3 id=&quot;4-이미지를-너비는-꽉-채우되-비율에-따라-높이를-동적으로-설정하고-싶은-경우&quot;&gt;4. 이미지를 너비는 꽉 채우되, 비율에 따라 높이를 동적으로 설정하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adjustViewBounds&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;로, 너비를 &lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;로 설정한다.&lt;br /&gt;
반대의 경우는 너비와 높이를 바꿔 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;5-viewpager를-빠르게-스크롤-할-때-흰-배경이-보이는-경우&quot;&gt;5. &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPager&lt;/code&gt;를 빠르게 스크롤 할 때, 흰 배경이 보이는 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPager&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;offscreenPageLimit&lt;/code&gt;를 적절하게 설정해 페이지를 미리 로딩하도록 한다.&lt;br /&gt;
복잡한 뷰일수록 수치를 낮게 설정해야 과부하가 걸리지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;6-상태바-높이를-얻고-싶은-경우&quot;&gt;6. 상태바 높이를 얻고 싶은 경우&lt;/h3&gt;

&lt;p&gt;상태바 높이에 해당하는 리소스를 찾아내 구할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStatusBarHeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Resources&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getResources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resourceId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getIdentifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;status_bar_height&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;dimen&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;android&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resourceId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDimensionPixelSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resourceId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;7-bottom-sheet-dialog의-드래그-동작을-막고-싶은-경우&quot;&gt;7. &lt;code class=&quot;highlighter-rouge&quot;&gt;Bottom Sheet Dialog&lt;/code&gt;의 드래그 동작을 막고 싶은 경우&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BottomSheetBehavior&lt;/code&gt;에 다음과 같은 콜백을 추가한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addBottomSheetCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BottomSheetBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;BottomSheetCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onStateChanged&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bottomSheet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BottomSheetBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;STATE_DRAGGING&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BottomSheetBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;STATE_EXPANDED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSlide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bottomSheet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slideOffset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;8-edittext-내부-스크롤을-활성화하고-싶은-경우&quot;&gt;8. &lt;code class=&quot;highlighter-rouge&quot;&gt;EditText&lt;/code&gt; 내부 스크롤을 활성화하고 싶은 경우&lt;/h3&gt;

&lt;p&gt;다음과 같은 터치 리스너를 추가한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;editText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setOnTouchListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;editText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasFocus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestDisallowInterceptTouchEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MotionEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ACTION_MASK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MotionEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ACTION_SCROLL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestDisallowInterceptTouchEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 16: 레거시 시스템은 지옥</title><link href="https://jamesu.dev/posts/2020/06/05/til-16-legacy-system-is-hell/" rel="alternate" type="text/html" title="TIL 16: 레거시 시스템은 지옥" /><published>2020-06-05T00:00:00+09:00</published><updated>2020-06-05T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/06/05/til-16-legacy-system-is-hell</id><content type="html" xml:base="https://jamesu.dev/posts/2020/06/05/til-16-legacy-system-is-hell/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;레거시 시스템은 가능하면 빨리 개선해서 지옥을 맞이하지 않도록 하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뉴저지-코볼cobol-사건으로-느껴지는-레거시-시스템의-폐해&quot;&gt;뉴저지 코볼(COBOL) 사건으로 느껴지는 레거시 시스템의 폐해&lt;/h2&gt;

&lt;p&gt;노마드 코더는 즐겨보는 유튜버 중 한명으로 다양한 프로그래밍 관련 이야기를 해준다.&lt;br /&gt;
가끔씩 재밌는 이슈도 이야기 해주는데, 이번에 들려준 이슈는 &lt;strong&gt;코볼(COBOL) 레거시 시스템에서 얻는 교훈&lt;/strong&gt;에 관한 것이었다.
(&lt;a href=&quot;https://youtu.be/LJ9TXkh9Xhk&quot; target=&quot;_blank&quot;&gt;유튜브 영상 링크&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;간단히 요약하자면,
미국 뉴저지 정부의 전산 시스템이 비교적 오래된 언어인 코볼로 이뤄져 있는 레거시 시스템인데, 개발자를 구할 수 없다는 것이다.
이번 코로나19 사태로 전산 시스템에 유래 없이 많은 사용자가 몰리게 되었고,
그것의 유지보수를 위해 코볼 개발자를 급하게 구하고 있지만 공급이 없어 애를 먹는 상황이다.&lt;/p&gt;

&lt;p&gt;오래된 언어답게 요즘 자주 사용하는 언어에 비하면 생산성도 떨어지고, 여러모로 단점이 많다.
이렇게 오랫동안 지속된 레거시 시스템은 진작에 시간을 두어 개편 작업을 해야 마땅한데 &lt;strong&gt;현업에서도 우선순위에서 밀리는 경우가 많다&lt;/strong&gt;.&lt;br /&gt;
이처럼 뉴저지 코볼 사건은 레거시 시스템이 낳은 안타까운 결과물 중 하나이다.&lt;/p&gt;

&lt;p&gt;비슷하게 (어디에나 존재할 수 있지만) 재직중인 회사에도 레거시 시스템이 존재한다.
그것의 구조적 한계로 인해 일부 유용한 개선도 못하고 있는 것이 보인다.&lt;br /&gt;
또한, 내가 맡고 있는 iOS 앱들도 불필요하게 Objective-C에 MRC 환경으로 되어 있다.
이런 환경일수록 더 디테일하게 다뤄야 하는데 그러지 못해 버그와 메모리 누수가 산발한다.&lt;/p&gt;

&lt;p&gt;뉴저지 코볼 사건처럼 나중에 후회하지 않으려면 &lt;strong&gt;일부 시간을 내서라도 구조, 환경 등의 개편을 진행해야 한다고 생각한다&lt;/strong&gt;.
그렇게 하나의 앱은 한달의 시간을 어떻게든 내어 Objective-C에서 Swift로 포팅을 진행했고, 여러모로 만족하고 있다.&lt;/p&gt;

&lt;p&gt;앞으로도 기회가 조금이라도 보이면, 기회를 만들어 기존 앱들의 포팅을 진행하거나 효율적인 구조로 개편하는 작업을 하고 싶다.
야근은 자제하면서 말이다.. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="idea" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 15: Notion은 유용해</title><link href="https://jamesu.dev/posts/2020/05/31/til-15-notion-is-useful/" rel="alternate" type="text/html" title="TIL 15: Notion은 유용해" /><published>2020-05-31T00:00:00+09:00</published><updated>2020-05-31T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/31/til-15-notion-is-useful</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/31/til-15-notion-is-useful/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.notion.so&quot; target=&quot;_blank&quot;&gt;Notion&lt;/a&gt; 툴은 개발자를 위한 &lt;strong&gt;메모 및 글 관리&lt;/strong&gt;에 유용하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;개발자를-위한-메모-및-글-관리-툴&quot;&gt;개발자를 위한 메모 및 글 관리 툴&lt;/h2&gt;

&lt;p&gt;개발을 하다보면 Code Snippet, 유용한 링크, 메모 등을 빠르게 작성하고, 보관하고 싶을 것이다.&lt;br /&gt;
&lt;a href=&quot;https://www.notion.so&quot; target=&quot;_blank&quot;&gt;Notion&lt;/a&gt;을 사용하면, 그 욕구를 잘 해소할 수 있다.&lt;/p&gt;

&lt;p&gt;이전에는 맥북에 내장되어 있는 메모 앱을 자주 사용하곤 했는데, 내용이 필요할 때마다 애플 계정 동기화 또는 로그인이 필요했다.
그래서 어디서든 빠르게 접근할 수 있는 메모가 필요했고, 우연히 웹 툴인 Notion을 접하게 되었다.&lt;/p&gt;

&lt;p&gt;이걸 왜 이제 알았는지 모르겠다.&lt;br /&gt;
간단하고 편리하고 개발자가 쓰기 좋은 기능들도 꽤 있다.&lt;br /&gt;
게다가 디자인이 내 취향이다. 😀&lt;/p&gt;

&lt;p&gt;한 문단과 비슷한 블록이라는 단위로 작성 단위를 측정하고 있다.&lt;br /&gt;
그것과 업로드 용량 등 여러 요소에 따라 요금제가 달라진다.&lt;br /&gt;
기본적으로 무료로 제공되는 양도 괜찮기 때문에 일단 사용해보고 판단하길 바란다.&lt;/p&gt;

&lt;p&gt;홍보대사는 아니지만, 이런 유용한 툴을 나만 알고 싶지 않아서 공유한다.&lt;br /&gt;
그동안 모르고 있었다면, 나처럼 빠져들지도 모른다. 😍&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="tool" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 14: TimePicker 때문에 자바의 Reflection을 쓰게 되다…</title><link href="https://jamesu.dev/posts/2020/05/28/til-14-long-time-no-see-reflection-of-java-for-time-picker/" rel="alternate" type="text/html" title="TIL 14: TimePicker 때문에 자바의 Reflection을 쓰게 되다..." /><published>2020-05-28T00:00:00+09:00</published><updated>2020-05-28T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/28/til-14-long-time-no-see-reflection-of-java-for-time-picker</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/28/til-14-long-time-no-see-reflection-of-java-for-time-picker/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;기본으로 제공되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;를 커스텀하기 위해 자바의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;을 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뭔가-제약이-많은-기본-timepicker&quot;&gt;뭔가 제약이 많은 기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;앱 개발을 하다 보면 디자인 요구사항을 위해 뷰를 커스텀 할 일이 많아진다.&lt;br /&gt;
그리고 다채로운 요구사항을 맞추다 보면, 커스텀하는 데 시간을 은근 빼았기곤 한다.&lt;/p&gt;

&lt;p&gt;이번에 회사에서 디자인 개선을 진행할 때는 일부 UI에 대해서는 시스템에서 제공하는 기본 UI를 사용하기로 해서 일을 많이 덜었다.
그래도 앱의 컨셉 컬러는 맞춰야 하니깐 기본 UI라도 그 컬러를 맞추고자 했다.&lt;/p&gt;

&lt;p&gt;그렇게 작업한 UI 중 하나가 기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;를 &lt;strong&gt;Spinner 모드&lt;/strong&gt;로 포함되어 있는 선의 색깔만 바꾸면 되는 것이었다.
당연히 5분도 안 걸릴 일이라 생각했고, 그것은 착오였다. ☠️&lt;/p&gt;

&lt;p&gt;기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 Spinner 모드는 XML을 통한 레이아웃에서만 설정할 수 있었고, 나는 코드를 통한 설정이 필요했다.
굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt; 하나 때문에 불필요한 레이아웃 파일을 하나 더 늘리기는 싫었고 코드를 통해 설정하고자 했지만,
관련 설정 메소드가 없었고 과거에 사용하던 특정한 Theme를 설정해야 Spinner 모드로 작동하는 것이었다.&lt;br /&gt;
일단, 여기서 한 번 이리저리 헤맸었다.&lt;/p&gt;

&lt;p&gt;두 번째로 스타일 설정을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;에 포함되어 있는 선의 색깔을 쉽게 바꿀 수 있는줄 알았다.
이것도 당연히 5분도 안 걸릴 일이라 생각했지만, 그것 또한 착오였다. ☠️&lt;/p&gt;

&lt;p&gt;일반적인 방법으로 Sinner 모드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 선(엄밀히 말하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt; 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberPicker&lt;/code&gt;의 선)에 접근하는 것은 불가능했다.
최후의 방법으로 자바의 API 중 하나인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;을 쓰게 되었다. 😂&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;을 쓰면 클래스 내부에 &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;인 멤버들에도 접근할 수 있고, 조작도 가능하다.
그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 내부 구조를 파악하고, 결국에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberPicker&lt;/code&gt;의 선의 색깔을 변경할 수 있었다.
웬만하면 쓸 일이 없는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;인데 이렇게 사용하니, 내가 까먹지 말라고 쓰게 해주는 것이구나 싶었다.&lt;/p&gt;

&lt;p&gt;기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 Spinner 모드도, 그 색깔을 변경하는 것도 자주 쓸만한 기능인데 왜 이렇게 꽁꽁 감싸 놓았는지 답답했었다.
그래도 ‘다 의도가 있겠지’라는 마음과 결국엔 해결했다는 것에 뿌듯함을 느낀다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="java" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 13: 안드로이드에서는 Image Asset Studio를 이용해 아이콘을 추가하자</title><link href="https://jamesu.dev/posts/2020/05/27/til-13-use-image-asset-studio-to-add-app-icon/" rel="alternate" type="text/html" title="TIL 13: 안드로이드에서는 Image Asset Studio를 이용해 아이콘을 추가하자" /><published>2020-05-27T00:00:00+09:00</published><updated>2020-05-27T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/27/til-13-use-image-asset-studio-to-add-app-icon</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/27/til-13-use-image-asset-studio-to-add-app-icon/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드에서 아이콘을 추가할 때,
Android Studio의 &lt;strong&gt;Image Asset Studio&lt;/strong&gt;를 이용하면 쉽게 &lt;strong&gt;여러 종류의 아이콘(적응형 및 레거시 아이콘 포함)&lt;/strong&gt;을 생성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;적응형-및-레거시-아이콘-추가를-위한-image-asset-studio&quot;&gt;적응형 및 레거시 아이콘 추가를 위한 Image Asset Studio&lt;/h2&gt;

&lt;p&gt;안드로이드 개발자라면 많은 사람들이 Android Studio를 사용할 것이다.&lt;br /&gt;
Android Studio는 앱 개발을 위한 많은 편리한 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;그 중 하나가 앱 개발을 위한 Asset을 손쉽게 추가하고 관리할 수 있도록 지원해준다는 것이다.
특히, 아이콘의 경우, &lt;strong&gt;안드로이드 OS 버전에 따라 사용하는 아이콘 모양이 상이&lt;/strong&gt;하기 때문에
직접 파편화에 대응해 Asset을 준비한다면 정말 손이 많이 가는 일이 될 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;이번에 회사에서 기존 앱의 전면 디자인 개선 작업을 하면서 앱 아이콘 또한 변경의 대상이었기 때문에 교체가 필요했다.
기존에 존재하던 앱 아이콘은 하나의 이미지로 여러 아이콘을 커버하도록 대충 되어 있었다.
그래서 싹 지우고, Android Studio에서 제공하는 &lt;strong&gt;Image Asset Studio&lt;/strong&gt;를 이용해 아이콘을 추가했더니
레거시까지 고려해 아름답게 여러 아이콘이 생성되어 한방에 해결할 수 있었다.&lt;/p&gt;

&lt;p&gt;더 궁금한 것이 있다면, &lt;a href=&quot;https://developer.android.com/studio/write/image-asset-studio#access&quot; target=&quot;_blank&quot;&gt;공식 안드로이드 개발자 문서&lt;/a&gt;에 잘 설명되어 있다.&lt;br /&gt;
Android Studio는 안드로이드 개발자에게 정말 축복같은 IDE인 것 같다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="android-studio" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 12: iOS에 Auto Layout이 있다면, Android에는 ConstraintLayout이 있다!</title><link href="https://jamesu.dev/posts/2020/05/25/til-12-android-constraint-layout-similar-to-ios-auto-layout/" rel="alternate" type="text/html" title="TIL 12: iOS에 Auto Layout이 있다면, Android에는 ConstraintLayout이 있다!" /><published>2020-05-25T00:00:00+09:00</published><updated>2020-05-25T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/25/til-12-android-constraint-layout-similar-to-ios-auto-layout</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/25/til-12-android-constraint-layout-similar-to-ios-auto-layout/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt;을 사용하면,&lt;br /&gt;
iOS의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Layout&lt;/code&gt; 컨셉으로 레이아웃을 구성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ios-개발자에게-반가운-안드로이드의-constraintlayout&quot;&gt;iOS 개발자에게 반가운 안드로이드의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;iOS 개발자라면 스토리보드를 사용하든 코드로 작성하든 &lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Layout&lt;/code&gt;을 이용해 뷰를 구성한 경험이 있을 것이다.
&lt;strong&gt;제약 조건(Constraint)&lt;/strong&gt;을 이렇게 저렇게 (잘) 걸어두면, &lt;strong&gt;화면의 변화에 따라 뷰가 자동으로 배치되고 크기가 변하게 할 수 있다&lt;/strong&gt;.
물론, 잘 설정한다는 가정이 필요하다.
잘못 설정하면 레이아웃이 엄청 깨지는 것을 경험할 수 있으므로, 제약 조건에 대한 이해가 확실해야 한다.&lt;/p&gt;

&lt;p&gt;아무튼 익숙해진다면, 아주 편리하게 뷰를 배치할 수 있을 것이다.
현재 회사에서 스토리보드를 사용하지 않고, 코드로만 뷰를 작성하는 프로젝트를 많이 하고 있기 때문에 정말 유용하게 사용하고 있다.
(&lt;del&gt;기존 레거시 코드는 좌표와 크기를 일일이 계산하면서 뷰를 작성해 유지보수가 지옥이다.&lt;/del&gt; 😇 &lt;del&gt;특히, 테이블 뷰 셀&lt;/del&gt;… ☠️)&lt;/p&gt;

&lt;p&gt;그러다 안드로이드 프로젝트를 진행하고 있는데, 옛날에 사용하던 &lt;code class=&quot;highlighter-rouge&quot;&gt;RelativeLayout&lt;/code&gt;은 뭔가 되게 어설프다.
원하는 레이아웃을 깔끔하게 구성하기 어려웠다.
그러던 중에 우연히 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt;을 알게 되었다.&lt;/p&gt;

&lt;p&gt;이름을 보자마자 익숙한 단어가 보였다.
&lt;strong&gt;Constraint&lt;/strong&gt;라는 단어가 이름에 붙은 것부터 &lt;strong&gt;제약 조건을 이용해 레이아웃을 구성&lt;/strong&gt;한다는 것을 유추할 수 있다.
그리고 직접 사용해보니 iOS의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Layout&lt;/code&gt;가 매우 유사했다!
아주 반가웠고, 그 컨셉에 빠르게 적응할 수 있었다.&lt;/p&gt;

&lt;p&gt;현재는 안드로이드 프로젝트에서도 유용하게 잘 사용하고 있다.&lt;br /&gt;
역시 익숙한 것이 좋은 것이여. 🙂&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 11: 다중 비동기 완료 처리를 위한 dispatch_group</title><link href="https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks/" rel="alternate" type="text/html" title="TIL 11: 다중 비동기 완료 처리를 위한 dispatch_group" /><published>2020-05-22T00:00:00+09:00</published><updated>2020-05-22T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;다중 비동기 처리가 완료되는 시점에 후속 처리를 하고 싶다면,&lt;br /&gt;
간단히 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 시리즈를 활용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;모든-이미지-다운로드가-완료-됐을-때-로딩바-숨기기&quot;&gt;모든 이미지 다운로드가 완료 됐을 때, 로딩바 숨기기&lt;/h2&gt;

&lt;p&gt;동적으로 화면에 이미지를 보여주기 위해 다운로드가 필요할 때가 있다.
그때 많이 사용하는 방식은 각 이미지가 다운로드될 때마다 이미지 뷰에 표시하도록 해서
로딩바가 표시되더라도 각 이미지 뷰에 표시하도록 하는 것이다.
그런 처리는 일반적인 비동기 처리로 손쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만, 이번에 새로운 요구사항이 생겼다.
모든 이미지가 다운로드될 때까지 중앙에 로딩바를 표시하고,
모두 완료되고 나서 로딩바를 숨긴 후 다른 동작을 할 수 있도록 처리하는 것이다.
이것을 위해서는 &lt;strong&gt;각 비동기 처리(이미지 다운로드)가 완료되는 시점을 알아야 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;iOS에서 비동기 처리를 위한 방법으로 크게 두 가지가 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Operation&lt;/code&gt; 시리즈와 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 시리즈이다.
이번에는 간단하게 모든 이미지 다운로드가 완료됐을 때 로딩바를 숨기면 되므로, 비교적 단순한 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 시리즈를 이용했다.&lt;/p&gt;

&lt;p&gt;그 중에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 시리즈를 이용하면, 각 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 작업들을 &lt;strong&gt;그룹화&lt;/strong&gt;하고
완료되는 시점에 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt; 함수에 정의한 동작을 수행하도록 할 수 있다.&lt;/p&gt;

&lt;p&gt;이것도 한 번 시간을 내어 글로 정리해야겠다.&lt;br /&gt;
정말 정리할 글이 많다… 🤪&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><category term="gcd" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 10: 폰트를 적용했는데 뜬금없는 패딩이 들어가 있다면?</title><link href="https://jamesu.dev/posts/2020/05/21/til-10-when-there-are-unexpected-paddings-for-font-in-text/" rel="alternate" type="text/html" title="TIL 10: 폰트를 적용했는데 뜬금없는 패딩이 들어가 있다면?" /><published>2020-05-21T00:00:00+09:00</published><updated>2020-05-21T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/21/til-10-when-there-are-unexpected-paddings-for-font-in-text</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/21/til-10-when-there-are-unexpected-paddings-for-font-in-text/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;커스텀 폰트를 적용했을 때 글자에 자동으로 추가되는 상하 패딩을 없애려면,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;includeFontPadding&lt;/code&gt; 속성을 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;당황스러운-글자의-상하-패딩&quot;&gt;당황스러운 글자의 상하 패딩&lt;/h2&gt;

&lt;p&gt;커스텀 폰트를 적용하면서 뜬금없는 상하 패딩이 생겨 당황스러웠다.
디자인 요구사항을 만족시키려면 패딩 없이 높이가 딱 맞는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TextView&lt;/code&gt;가 필요했다.
iOS 앱 개발 때와는 다른 당황스러움이었다. (iOS도 가끔 특이한 속성이 있다.)&lt;/p&gt;

&lt;p&gt;구글링을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;includeFontPadding&lt;/code&gt;라는 속성이 있다는 것을 알았고, 그것을 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; 처리함으로써 해결했다.
왜 기본값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;인지 모르겠다…
물론 용도가 있겠지만, 오히려 선택적 옵션이어야 할 것 같은데 말이다. 🙄&lt;/p&gt;

&lt;p&gt;알게 모르게 안드로이드에도 iOS만큼이나 다양한 속성이 있는 것 같다.&lt;br /&gt;
구글이 없었다면, 매번 책을 엄청 뒤지고 있었겠지… 😱&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 9: 안드로이드 커스텀 스타일 적용하기</title><link href="https://jamesu.dev/posts/2020/05/20/til-9-applying-custom-style-in-android/" rel="alternate" type="text/html" title="TIL 9: 안드로이드 커스텀 스타일 적용하기" /><published>2020-05-20T00:00:00+09:00</published><updated>2020-05-20T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/20/til-9-applying-custom-style-in-android</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/20/til-9-applying-custom-style-in-android/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;테마에 일반적인 뷰 스타일을 설정&lt;/strong&gt;해 앱 전반에 공통적으로 스타일을 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스타일-공통화&quot;&gt;스타일 공통화&lt;/h2&gt;

&lt;p&gt;일반적으로 앱을 개발하면, 공통적으로 적용되는 스타일이 있을 것이다.
예를 들면, 특정 앱에서 사용하는 버튼은 일반적으로 8dp의 cornerRadius를 가지고 회색 배경인 버튼일 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 이렇게 자주 쓰이는 공통 버튼을 매번 스타일링 해주기에는 개발자에겐 귀차니즘이 너무 심하다.
실수로 스타일링 구문을 한 줄이라도 빼먹으면, 상이한 디자인의 버튼이 나타날 수 있다.
그래서 &lt;strong&gt;가급적이면 공통 스타일을 정의하고 재활용하는 것이 효율적&lt;/strong&gt;일 것이다.&lt;/p&gt;

&lt;p&gt;이를 위해 다른 개발 환경에서 공통 스타일을 적용한다면,
일반적으로 서브 클래스를 만들어 해당 클래스에 공통 스타일을 적용해놓고 쓸 것이다.
안드로이드에서도 그 방법이 가능하지만, 더 간단한 방법이 있다.&lt;/p&gt;

&lt;p&gt;바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt; 요소로 공통 스타일을 정의하고, &lt;strong&gt;기본적으로 적용한 테마에 해당 스타일을 사용하도록 설정&lt;/strong&gt;하는 것이다.
예를 들어, 공통 버튼 스타일을 적용하고 싶으면, 테마의 &lt;code class=&quot;highlighter-rouge&quot;&gt;buttonStyle&lt;/code&gt; 아이템에 정의한 &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt; 요소를 설정하면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;App.Theme&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parent=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Theme.AppCompat.Light.DarkActionBar&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android:buttonStyle&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;@style/App.Widget.Button&lt;span class=&quot;nt&quot;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;App.Widget.Button&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parent=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@android:style/Widget.Button&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android:background&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;@color/colorPrimary&lt;span class=&quot;nt&quot;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android:textColor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;@android:color/white&lt;span class=&quot;nt&quot;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드와 같이 설정하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;App.Theme&lt;/code&gt; 테마의 버튼은 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;App.Widget.Button&lt;/code&gt; 스타일을 갖는다.
따라서, 앱의 기본 테마로 &lt;code class=&quot;highlighter-rouge&quot;&gt;App.Theme&lt;/code&gt; 테마를 적용하면, 추가적으로 변경하지 않는 한 모든 액티비티가 동일한 버튼 스타일을 갖는 것이다.&lt;/p&gt;

&lt;p&gt;이 밖에도 다양한 뷰에 대해 공통 스타일을 적용할 수 있으므로 참으로 편리하다.
물론, 스타일링뿐 아니라 다른 기능도 적용하고 싶으면 서브 클래스로 정의하는 것이 더 나을 수 있다. 🙄&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry></feed>