<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko_KR"><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://jamesu.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jamesu.dev/" rel="alternate" type="text/html" hreflang="ko_KR" /><updated>2020-06-08T00:34:49+09:00</updated><id>https://jamesu.dev/</id><title type="html">Jamesu Devlog</title><subtitle>Dev Blog by James Minsu Jeon</subtitle><author><name>jamesujeon</name><email>jamesujeon@gmail.com</email></author><entry><title type="html">TIL 15: Notion은 유용해</title><link href="https://jamesu.dev/posts/2020/05/31/til-15-notion-is-useful/" rel="alternate" type="text/html" title="TIL 15: Notion은 유용해" /><published>2020-05-31T00:00:00+09:00</published><updated>2020-05-31T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/31/til-15-notion-is-useful</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/31/til-15-notion-is-useful/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.notion.so&quot; target=&quot;_blank&quot;&gt;Notion&lt;/a&gt; 툴은 개발자를 위한 &lt;strong&gt;메모 및 글 관리&lt;/strong&gt;에 유용하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;개발자를-위한-메모-및-글-관리-툴&quot;&gt;개발자를 위한 메모 및 글 관리 툴&lt;/h2&gt;

&lt;p&gt;개발을 하다보면 Code Snippet, 유용한 링크, 메모 등을 빠르게 작성하고, 보관하고 싶을 것이다.&lt;br /&gt;
&lt;a href=&quot;https://www.notion.so&quot; target=&quot;_blank&quot;&gt;Notion&lt;/a&gt;을 사용하면, 그 욕구를 잘 해소할 수 있다.&lt;/p&gt;

&lt;p&gt;이전에는 맥북에 내장되어 있는 메모 앱을 자주 사용하곤 했는데, 내용이 필요할 때마다 애플 계정 동기화 또는 로그인이 필요했다.
그래서 어디서든 빠르게 접근할 수 있는 메모가 필요했고, 우연히 웹 툴인 Notion을 접하게 되었다.&lt;/p&gt;

&lt;p&gt;이걸 왜 이제 알았는지 모르겠다.&lt;br /&gt;
간단하고 편리하고 개발자가 쓰기 좋은 기능들도 꽤 있다.&lt;br /&gt;
게다가 디자인이 내 취향이다. 😀&lt;/p&gt;

&lt;p&gt;한 문단과 비슷한 블록이라는 단위로 작성 단위를 측정하고 있다.&lt;br /&gt;
그것과 업로드 용량 등 여러 요소에 따라 요금제가 달라진다.&lt;br /&gt;
기본적으로 무료로 제공되는 양도 괜찮기 때문에 일단 사용해보고 판단하길 바란다.&lt;/p&gt;

&lt;p&gt;홍보대사는 아니지만, 이런 유용한 툴을 나만 알고 싶지 않아서 공유한다.&lt;br /&gt;
그동안 모르고 있었다면, 나처럼 빠져들지도 모른다. 😍&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="tool" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 14: TimePicker 때문에 자바의 Reflection을 쓰게 되다…</title><link href="https://jamesu.dev/posts/2020/05/28/til-14-long-time-no-see-reflection-of-java-for-time-picker/" rel="alternate" type="text/html" title="TIL 14: TimePicker 때문에 자바의 Reflection을 쓰게 되다..." /><published>2020-05-28T00:00:00+09:00</published><updated>2020-05-28T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/28/til-14-long-time-no-see-reflection-of-java-for-time-picker</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/28/til-14-long-time-no-see-reflection-of-java-for-time-picker/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;기본으로 제공되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;를 커스텀하기 위해 자바의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;을 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뭔가-제약이-많은-기본-timepicker&quot;&gt;뭔가 제약이 많은 기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;앱 개발을 하다 보면 디자인 요구사항을 위해 뷰를 커스텀 할 일이 많아진다.&lt;br /&gt;
그리고 다채로운 요구사항을 맞추다 보면, 커스텀하는 데 시간을 은근 빼았기곤 한다.&lt;/p&gt;

&lt;p&gt;이번에 회사에서 디자인 개선을 진행할 때는 일부 UI에 대해서는 시스템에서 제공하는 기본 UI를 사용하기로 해서 일을 많이 덜었다.
그래도 앱의 컨셉 컬러는 맞춰야 하니깐 기본 UI라도 그 컬러를 맞추고자 했다.&lt;/p&gt;

&lt;p&gt;그렇게 작업한 UI 중 하나가 기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;를 &lt;strong&gt;Spinner 모드&lt;/strong&gt;로 포함되어 있는 선의 색깔만 바꾸면 되는 것이었다.
당연히 5분도 안 걸릴 일이라 생각했고, 그것은 착오였다. ☠️&lt;/p&gt;

&lt;p&gt;기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 Spinner 모드는 XML을 통한 레이아웃에서만 설정할 수 있었고, 나는 코드를 통한 설정이 필요했다.
굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt; 하나 때문에 불필요한 레이아웃 파일을 하나 더 늘리기는 싫었고 코드를 통해 설정하고자 했지만,
관련 설정 메소드가 없었고 과거에 사용하던 특정한 Theme를 설정해야 Spinner 모드로 작동하는 것이었다.&lt;br /&gt;
일단, 여기서 한 번 이리저리 헤맸었다.&lt;/p&gt;

&lt;p&gt;두 번째로 스타일 설정을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;에 포함되어 있는 선의 색깔을 쉽게 바꿀 수 있는줄 알았다.
이것도 당연히 5분도 안 걸릴 일이라 생각했지만, 그것 또한 착오였다. ☠️&lt;/p&gt;

&lt;p&gt;일반적인 방법으로 Sinner 모드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 선(엄밀히 말하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt; 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberPicker&lt;/code&gt;의 선)에 접근하는 것은 불가능했다.
최후의 방법으로 자바의 API 중 하나인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;을 쓰게 되었다. 😂&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;을 쓰면 클래스 내부에 &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;인 멤버들에도 접근할 수 있고, 조작도 가능하다.
그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 내부 구조를 파악하고, 결국에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberPicker&lt;/code&gt;의 선의 색깔을 변경할 수 있었다.
웬만하면 쓸 일이 없는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;인데 이렇게 사용하니, 내가 까먹지 말라고 쓰게 해주는 것이구나 싶었다.&lt;/p&gt;

&lt;p&gt;기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimePicker&lt;/code&gt;의 Spinner 모드도, 그 색깔을 변경하는 것도 자주 쓸만한 기능인데 왜 이렇게 꽁꽁 감싸 놓았는지 답답했었다.
그래도 ‘다 의도가 있겠지’라는 마음과 결국엔 해결했다는 것에 뿌듯함을 느낀다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="java" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 13: 안드로이드에서는 Image Asset Studio를 이용해 아이콘을 추가하자</title><link href="https://jamesu.dev/posts/2020/05/27/til-13-use-image-asset-studio-to-add-app-icon/" rel="alternate" type="text/html" title="TIL 13: 안드로이드에서는 Image Asset Studio를 이용해 아이콘을 추가하자" /><published>2020-05-27T00:00:00+09:00</published><updated>2020-05-27T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/27/til-13-use-image-asset-studio-to-add-app-icon</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/27/til-13-use-image-asset-studio-to-add-app-icon/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드에서 아이콘을 추가할 때,
Android Studio의 &lt;strong&gt;Image Asset Studio&lt;/strong&gt;를 이용하면 쉽게 &lt;strong&gt;여러 종류의 아이콘(적응형 및 레거시 아이콘 포함)&lt;/strong&gt;을 생성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;적응형-및-레거시-아이콘-추가를-위한-image-asset-studio&quot;&gt;적응형 및 레거시 아이콘 추가를 위한 Image Asset Studio&lt;/h2&gt;

&lt;p&gt;안드로이드 개발자라면 많은 사람들이 Android Studio를 사용할 것이다.&lt;br /&gt;
Android Studio는 앱 개발을 위한 많은 편리한 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;그 중 하나가 앱 개발을 위한 Asset을 손쉽게 추가하고 관리할 수 있도록 지원해준다는 것이다.
특히, 아이콘의 경우, &lt;strong&gt;안드로이드 OS 버전에 따라 사용하는 아이콘 모양이 상이&lt;/strong&gt;하기 때문에
직접 파편화에 대응해 Asset을 준비한다면 정말 손이 많이 가는 일이 될 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;이번에 회사에서 기존 앱의 전면 디자인 개선 작업을 하면서 앱 아이콘 또한 변경의 대상이었기 때문에 교체가 필요했다.
기존에 존재하던 앱 아이콘은 하나의 이미지로 여러 아이콘을 커버하도록 대충 되어 있었다.
그래서 싹 지우고, Android Studio에서 제공하는 &lt;strong&gt;Image Asset Studio&lt;/strong&gt;를 이용해 아이콘을 추가했더니
레거시까지 고려해 아름답게 여러 아이콘이 생성되어 한방에 해결할 수 있었다.&lt;/p&gt;

&lt;p&gt;더 궁금한 것이 있다면, &lt;a href=&quot;https://developer.android.com/studio/write/image-asset-studio#access&quot; target=&quot;_blank&quot;&gt;공식 안드로이드 개발자 문서&lt;/a&gt;에 잘 설명되어 있다.&lt;br /&gt;
Android Studio는 안드로이드 개발자에게 정말 축복같은 IDE인 것 같다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="android-studio" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 12: iOS에 Auto Layout이 있다면, Android에는 ConstraintLayout이 있다!</title><link href="https://jamesu.dev/posts/2020/05/25/til-12-android-constraint-layout-similar-to-ios-auto-layout/" rel="alternate" type="text/html" title="TIL 12: iOS에 Auto Layout이 있다면, Android에는 ConstraintLayout이 있다!" /><published>2020-05-25T00:00:00+09:00</published><updated>2020-05-25T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/25/til-12-android-constraint-layout-similar-to-ios-auto-layout</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/25/til-12-android-constraint-layout-similar-to-ios-auto-layout/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt;을 사용하면,&lt;br /&gt;
iOS의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Layout&lt;/code&gt; 컨셉으로 레이아웃을 구성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ios-개발자에게-반가운-안드로이드의-constraintlayout&quot;&gt;iOS 개발자에게 반가운 안드로이드의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;iOS 개발자라면 스토리보드를 사용하든 코드로 작성하든 &lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Layout&lt;/code&gt;을 이용해 뷰를 구성한 경험이 있을 것이다.
&lt;strong&gt;제약 조건(Constraint)&lt;/strong&gt;을 이렇게 저렇게 (잘) 걸어두면, &lt;strong&gt;화면의 변화에 따라 뷰가 자동으로 배치되고 크기가 변하게 할 수 있다&lt;/strong&gt;.
물론, 잘 설정한다는 가정이 필요하다.
잘못 설정하면 레이아웃이 엄청 깨지는 것을 경험할 수 있으므로, 제약 조건에 대한 이해가 확실해야 한다.&lt;/p&gt;

&lt;p&gt;아무튼 익숙해진다면, 아주 편리하게 뷰를 배치할 수 있을 것이다.
현재 회사에서 스토리보드를 사용하지 않고, 코드로만 뷰를 작성하는 프로젝트를 많이 하고 있기 때문에 정말 유용하게 사용하고 있다.
(&lt;del&gt;기존 레거시 코드는 좌표와 크기를 일일이 계산하면서 뷰를 작성해 유지보수가 지옥이다.&lt;/del&gt; 😇 &lt;del&gt;특히, 테이블 뷰 셀&lt;/del&gt;… ☠️)&lt;/p&gt;

&lt;p&gt;그러다 안드로이드 프로젝트를 진행하고 있는데, 옛날에 사용하던 &lt;code class=&quot;highlighter-rouge&quot;&gt;RelativeLayout&lt;/code&gt;은 뭔가 되게 어설프다.
원하는 레이아웃을 깔끔하게 구성하기 어려웠다.
그러던 중에 우연히 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt;을 알게 되었다.&lt;/p&gt;

&lt;p&gt;이름을 보자마자 익숙한 단어가 보였다.
&lt;strong&gt;Constraint&lt;/strong&gt;라는 단어가 이름에 붙은 것부터 &lt;strong&gt;제약 조건을 이용해 레이아웃을 구성&lt;/strong&gt;한다는 것을 유추할 수 있다.
그리고 직접 사용해보니 iOS의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Layout&lt;/code&gt;가 매우 유사했다!
아주 반가웠고, 그 컨셉에 빠르게 적응할 수 있었다.&lt;/p&gt;

&lt;p&gt;현재는 안드로이드 프로젝트에서도 유용하게 잘 사용하고 있다.&lt;br /&gt;
역시 익숙한 것이 좋은 것이여. 🙂&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 11: 다중 비동기 완료 처리를 위한 dispatch_group</title><link href="https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks/" rel="alternate" type="text/html" title="TIL 11: 다중 비동기 완료 처리를 위한 dispatch_group" /><published>2020-05-22T00:00:00+09:00</published><updated>2020-05-22T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/22/til-11-dispatch-group-for-multiple-asynchronous-tasks/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;다중 비동기 처리가 완료되는 시점에 후속 처리를 하고 싶다면,&lt;br /&gt;
간단히 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 시리즈를 활용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;모든-이미지-다운로드가-완료-됐을-때-로딩바-숨기기&quot;&gt;모든 이미지 다운로드가 완료 됐을 때, 로딩바 숨기기&lt;/h2&gt;

&lt;p&gt;동적으로 화면에 이미지를 보여주기 위해 다운로드가 필요할 때가 있다.
그때 많이 사용하는 방식은 각 이미지가 다운로드될 때마다 이미지 뷰에 표시하도록 해서
로딩바가 표시되더라도 각 이미지 뷰에 표시하도록 하는 것이다.
그런 처리는 일반적인 비동기 처리로 손쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만, 이번에 새로운 요구사항이 생겼다.
모든 이미지가 다운로드될 때까지 중앙에 로딩바를 표시하고,
모두 완료되고 나서 로딩바를 숨긴 후 다른 동작을 할 수 있도록 처리하는 것이다.
이것을 위해서는 &lt;strong&gt;각 비동기 처리(이미지 다운로드)가 완료되는 시점을 알아야 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;iOS에서 비동기 처리를 위한 방법으로 크게 두 가지가 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Operation&lt;/code&gt; 시리즈와 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 시리즈이다.
이번에는 간단하게 모든 이미지 다운로드가 완료됐을 때 로딩바를 숨기면 되므로, 비교적 단순한 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 시리즈를 이용했다.&lt;/p&gt;

&lt;p&gt;그 중에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 시리즈를 이용하면, 각 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 작업들을 &lt;strong&gt;그룹화&lt;/strong&gt;하고
완료되는 시점에 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt; 함수에 정의한 동작을 수행하도록 할 수 있다.&lt;/p&gt;

&lt;p&gt;이것도 한 번 시간을 내어 글로 정리해야겠다.&lt;br /&gt;
정말 정리할 글이 많다… 🤪&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><category term="gcd" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 10: 폰트를 적용했는데 뜬금없는 패딩이 들어가 있다면?</title><link href="https://jamesu.dev/posts/2020/05/21/til-10-when-there-are-unexpected-paddings-for-font-in-text/" rel="alternate" type="text/html" title="TIL 10: 폰트를 적용했는데 뜬금없는 패딩이 들어가 있다면?" /><published>2020-05-21T00:00:00+09:00</published><updated>2020-05-21T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/21/til-10-when-there-are-unexpected-paddings-for-font-in-text</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/21/til-10-when-there-are-unexpected-paddings-for-font-in-text/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;커스텀 폰트를 적용했을 때 글자에 자동으로 추가되는 상하 패딩을 없애려면,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;includeFontPadding&lt;/code&gt; 속성을 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;당황스러운-글자의-상하-패딩&quot;&gt;당황스러운 글자의 상하 패딩&lt;/h2&gt;

&lt;p&gt;커스텀 폰트를 적용하면서 뜬금없는 상하 패딩이 생겨 당황스러웠다.
디자인 요구사항을 만족시키려면 패딩 없이 높이가 딱 맞는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TextView&lt;/code&gt;가 필요했다.
iOS 앱 개발 때와는 다른 당황스러움이었다. (iOS도 가끔 특이한 속성이 있다.)&lt;/p&gt;

&lt;p&gt;구글링을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;includeFontPadding&lt;/code&gt;라는 속성이 있다는 것을 알았고, 그것을 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; 처리함으로써 해결했다.
왜 기본값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;인지 모르겠다…
물론 용도가 있겠지만, 오히려 선택적 옵션이어야 할 것 같은데 말이다. 🙄&lt;/p&gt;

&lt;p&gt;알게 모르게 안드로이드에도 iOS만큼이나 다양한 속성이 있는 것 같다.&lt;br /&gt;
구글이 없었다면, 매번 책을 엄청 뒤지고 있었겠지… 😱&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 9: 안드로이드 커스텀 스타일 적용하기</title><link href="https://jamesu.dev/posts/2020/05/20/til-9-applying-custom-style-in-android/" rel="alternate" type="text/html" title="TIL 9: 안드로이드 커스텀 스타일 적용하기" /><published>2020-05-20T00:00:00+09:00</published><updated>2020-05-20T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/20/til-9-applying-custom-style-in-android</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/20/til-9-applying-custom-style-in-android/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;테마에 일반적인 뷰 스타일을 설정&lt;/strong&gt;해 앱 전반에 공통적으로 스타일을 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스타일-공통화&quot;&gt;스타일 공통화&lt;/h2&gt;

&lt;p&gt;일반적으로 앱을 개발하면, 공통적으로 적용되는 스타일이 있을 것이다.
예를 들면, 특정 앱에서 사용하는 버튼은 일반적으로 8dp의 cornerRadius를 가지고 회색 배경인 버튼일 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 이렇게 자주 쓰이는 공통 버튼을 매번 스타일링 해주기에는 개발자에겐 귀차니즘이 너무 심하다.
실수로 스타일링 구문을 한 줄이라도 빼먹으면, 상이한 디자인의 버튼이 나타날 수 있다.
그래서 &lt;strong&gt;가급적이면 공통 스타일을 정의하고 재활용하는 것이 효율적&lt;/strong&gt;일 것이다.&lt;/p&gt;

&lt;p&gt;이를 위해 다른 개발 환경에서 공통 스타일을 적용한다면,
일반적으로 서브 클래스를 만들어 해당 클래스에 공통 스타일을 적용해놓고 쓸 것이다.
안드로이드에서도 그 방법이 가능하지만, 더 간단한 방법이 있다.&lt;/p&gt;

&lt;p&gt;바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt; 요소로 공통 스타일을 정의하고, &lt;strong&gt;기본적으로 적용한 테마에 해당 스타일을 사용하도록 설정&lt;/strong&gt;하는 것이다.
예를 들어, 공통 버튼 스타일을 적용하고 싶으면, 테마의 &lt;code class=&quot;highlighter-rouge&quot;&gt;buttonStyle&lt;/code&gt; 아이템에 정의한 &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt; 요소를 설정하면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;App.Theme&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parent=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Theme.AppCompat.Light.DarkActionBar&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android:buttonStyle&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;@style/App.Widget.Button&lt;span class=&quot;nt&quot;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;App.Widget.Button&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parent=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@android:style/Widget.Button&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android:background&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;@color/colorPrimary&lt;span class=&quot;nt&quot;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android:textColor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;@android:color/white&lt;span class=&quot;nt&quot;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드와 같이 설정하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;App.Theme&lt;/code&gt; 테마의 버튼은 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;App.Widget.Button&lt;/code&gt; 스타일을 갖는다.
따라서, 앱의 기본 테마로 &lt;code class=&quot;highlighter-rouge&quot;&gt;App.Theme&lt;/code&gt; 테마를 적용하면, 추가적으로 변경하지 않는 한 모든 액티비티가 동일한 버튼 스타일을 갖는 것이다.&lt;/p&gt;

&lt;p&gt;이 밖에도 다양한 뷰에 대해 공통 스타일을 적용할 수 있으므로 참으로 편리하다.
물론, 스타일링뿐 아니라 다른 기능도 적용하고 싶으면 서브 클래스로 정의하는 것이 더 나을 수 있다. 🙄&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="android" /><category term="ui" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 8: HTTP 메시지로 다중 파일 업로드하기</title><link href="https://jamesu.dev/posts/2020/05/19/til-8-uploading-multiple-files-with-http-message/" rel="alternate" type="text/html" title="TIL 8: HTTP 메시지로 다중 파일 업로드하기" /><published>2020-05-19T00:00:00+09:00</published><updated>2020-05-19T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/19/til-8-uploading-multiple-files-with-http-message</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/19/til-8-uploading-multiple-files-with-http-message/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;동일한 파라미터&lt;/strong&gt;에 여러 번에 걸쳐 파일을 추가함으로써, &lt;strong&gt;다중 파일&lt;/strong&gt;을 업로드할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;동일한-파라미터냐-배열-형태의-파라미터냐-그것이-문제로다&quot;&gt;동일한 파라미터냐 배열 형태의 파라미터냐 그것이 문제로다.&lt;/h2&gt;

&lt;p&gt;매번 단일 파일 업로드만 구현하다가 이번에 &lt;strong&gt;다중 파일 업로드&lt;/strong&gt;가 필요한 요구사항이 들어 왔다.&lt;br /&gt;
앱에는 이미 오픈 소스 라이브러리를 사용하지 않고, &lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLSessionTask&lt;/code&gt;를 이용한 네트워크 처리가 되어 있었다.
그래서 기존 코드를 다 뒤집기 보다는 기존처럼 공식 프레임워크로 구현하려 했다.&lt;/p&gt;

&lt;p&gt;직접 구현을 하게 되면, 파일 업로드를 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;의 Content Type으로 API를 호출해야 한다.
그것을 위해 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 메시지의 Request Body를 구성해야 했고, 경험한 적이 있어서 어렵지 않게 기본적인 Body를 구성할 수 있었다.&lt;/p&gt;

&lt;p&gt;처음에는 서버쪽에서 배열로 파일 목록을 받으니 특정한 패턴으로 파라미터를 구분해 파일을 담아야 하는줄 알았다.
실제로 구글링을 할 때도 &lt;code class=&quot;highlighter-rouge&quot;&gt;files[0]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;files[1]&lt;/code&gt; 등과 같이 구분해 담으라는 답변이 있었다.
그럴듯해서 그대로 시도를 했으나 잘 안되어, 파라미터에 문제가 있지 않고 Body 구성에 실수가 있는줄 알고 그 부분만 계속 살펴 봤다.&lt;/p&gt;

&lt;p&gt;결국 &lt;strong&gt;해결책은 매우 간단하게 동일한 파라미터에 차례대로 담으면 되는 것&lt;/strong&gt;이었다. 🙄&lt;br /&gt;
파일이 아닌 다른 데이터도 서버에서 배열로 받는다면, 똑같이 동일한 파라미터에 데이터를 담으면 된다.&lt;/p&gt;

&lt;p&gt;개인적으로 동일한 파라미터로 보내면, 순서를 어떻게 구분할까 싶었는데 그 원리는 생각보다 아주 단순해 보였다.
위에서부터 차례대로 읽으면서 인덱스가 쌓이는 구조로 보인다.&lt;br /&gt;
&lt;strong&gt;두 종류의 데이터를 같은 인덱스로 보내고 싶으면, 순서에 유의해서 데이터를 담아야 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;이렇게 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 메시지를 구성하며 구현하는 것도 재미는 있지만, 역시 신뢰도 높은 오픈 소스 라이브러리가 사용하기에 편하다. 😌&lt;br /&gt;
그래도 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 메시지 구조를 모르고 오픈 소스 라이브러리를 사용하는 것과 알고 쓰는 것은 아주 다르니 꾸준히 공부해야겠다.&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><category term="http" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 7: MRC 속 ARC 조심하기</title><link href="https://jamesu.dev/posts/2020/05/18/til-7-be-careful-about-arc-in-mrc/" rel="alternate" type="text/html" title="TIL 7: MRC 속 ARC 조심하기" /><published>2020-05-18T00:00:00+09:00</published><updated>2020-05-18T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/18/til-7-be-careful-about-arc-in-mrc</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/18/til-7-be-careful-about-arc-in-mrc/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;로 생성되는 객체를 조심하자.&lt;br /&gt;
특히, &lt;strong&gt;객체 생성용 클래스 메소드&lt;/strong&gt;를 조심하자.&lt;br /&gt;
(예: &lt;code class=&quot;highlighter-rouge&quot;&gt;[NSArray array]&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mrc-환경-내부의-arc&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;iOS 개발을 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경에서 해 본 사람이라면, 곳곳에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;가 숨어 있다는 사실을 알 것이다.
그래서 이것을 잘못 알고 사용하면, 잘못된 메모리 참조로 인해 앱 크래시가 발생할 수 있다.
이것이 개발하고 테스트할 때 발견하지 못 하고, 출시한 후 사용자로부터 발견된다면…
급하게 버그를 수정하고 다시 배포하느냐 정신이 없을 것이다. 😱&lt;/p&gt;

&lt;p&gt;과거에 한창 Objective-C로 개발할 때는 숙지하고 있었는데 잠시 몇개월간 Swift의 세계에 있었다고,
까먹고 있어서 개발 중에 크래시가 발생하곤 했다.
다행히 기존에 문제가 있었던 메모리 누수 해결을 하면서 발견해서 상처를 잘 봉합했다.
다음에 꼭 메모리 관련해서 글을 한 번 정리해야겠다.&lt;/p&gt;

&lt;p&gt;간단히 말해서 통상적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;MRC&lt;/code&gt; 환경 속에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;로 사용하는 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 메소드를 호출한 경우이다.
보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt;로 사용하길 원하는 부분은 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 메소드를 호출하니 문제가 없을 것이다.
그런데, 입문자라면 잘 모를 수 있는 것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIKit&lt;/code&gt; 등과 같은 공식 프레임워크에 정의되어 있는 &lt;strong&gt;객체 생성용 클래스 메소드&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 메소드로 생성하지 않고, &lt;code class=&quot;highlighter-rouge&quot;&gt;[NSArray array]&lt;/code&gt; 메소드와 같은 클래스 메소드로 객체를 생성한 경험이 있을 것이다.
이 경우에 &lt;strong&gt;해당 메소드로 생성한 객체는 이미 &lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 메소드를 호출한 객체이므로, 추가적으로 메모리 해제를 하면 안 된다&lt;/strong&gt;.
다른 말로 &lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt; 메소드를 호출하면 안 된다.
이런 용도의 메소드는 &lt;strong&gt;클래스 이름을 본 딴 Prefix&lt;/strong&gt;를 가지므로, 여러 예시를 본다면 패턴에 익숙해질 것이다.&lt;/p&gt;

&lt;p&gt;또한, &lt;strong&gt;직접 커스텀 클래스에 객체 생성용 클래스 메소드를 정의한다면, 공식 프레임워크와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARC&lt;/code&gt; 객체로 생성하길 권장한다&lt;/strong&gt;.
그렇지 않으면, 혼동되어 더 많은 버그와 실수를 남길 것이다. ☠️&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="objective-c" /><summary type="html">TL;DR</summary></entry><entry><title type="html">TIL 6: unowned 레퍼런스 피하기</title><link href="https://jamesu.dev/posts/2020/05/17/til-6-avoiding-unowned-reference/" rel="alternate" type="text/html" title="TIL 6: unowned 레퍼런스 피하기" /><published>2020-05-17T00:00:00+09:00</published><updated>2020-05-17T00:00:00+09:00</updated><id>https://jamesu.dev/posts/2020/05/17/til-6-avoiding-unowned-reference</id><content type="html" xml:base="https://jamesu.dev/posts/2020/05/17/til-6-avoiding-unowned-reference/">&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 레퍼런스는 피하고, 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;을 사용하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;unowned-레퍼런스란-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 레퍼런스란? 🤔&lt;/h2&gt;

&lt;p&gt;Swift로 ARC 환경에서 iOS 앱을 개발할 때, 정말 중요한 개념이 있다.&lt;br /&gt;
바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Strong Reference Cycle(강한 참조 순환)&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;다른 것도 중요하지만, 이것을 모르고는 iOS 개발자라 할 수 없다.&lt;br /&gt;
그러므로, 다들 알 것이라 생각하고… 개념은 패스!&lt;/p&gt;

&lt;p&gt;ARC 환경에서 강한 참조 순환이 생겨 버리면, &lt;strong&gt;메모리에 할당된 대상을 해제할지 말지 판단을 하지 못 한다&lt;/strong&gt;.
계속 서로 참조하고 있어, 참조 카운트가 0이 될 수 없기 때문이다.
이를 방지하기 위한 문법으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조가 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조는 &lt;strong&gt;약한 참조&lt;/strong&gt;라 부르고, &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조는 &lt;strong&gt;미소유 참조&lt;/strong&gt;라 부를 수 있다.&lt;br /&gt;
두 참조의 가장 중요한 특징은 &lt;strong&gt;참조 카운트를 증가시키지 않는 것&lt;/strong&gt;이다.
계속 참조하고 있어도 참조 카운트에 영향을 미치지 않기 때문에,
다른 강한 참조가 사라져 메모리가 해제되는 데 지장이 없다.&lt;/p&gt;

&lt;p&gt;또한, &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조는 참조하는 대상의 메모리가 해제되면 자동으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;로 설정되지만,
&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조는 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;로 설정되지 않고 &lt;strong&gt;항상 값이 있다고 가정&lt;/strong&gt;해 버린다.
여기서 생명 주기를 잘못 생각해 이미 메모리 해제된 대상을 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 통해 접근했을 때,
운이 없다면 앱이 그대로 사망할 수 있다. ☠️&lt;/p&gt;

&lt;p&gt;그래서 생명 주기가 확실한 경우에만 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 사용할 것을 &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html&quot; target=&quot;_blank&quot;&gt;Swift 공식 문서&lt;/a&gt;에서도 강조한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use an unowned reference only when you are sure that
the reference always refers to an instance that has not been deallocated.&lt;/p&gt;

  &lt;p&gt;If you try to access the value of an unowned reference
after that instance has been deallocated, &lt;strong&gt;you’ll get a runtime error&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;안전하게-weak-레퍼런스로-통일하자-️&quot;&gt;안전하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 레퍼런스로 통일하자! 👷‍♂️&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 언제 사용하면 좋을 지는 &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html&quot; target=&quot;_blank&quot;&gt;해당 문서&lt;/a&gt;에 예시와 함께 잘 적혀 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조에 비해 Unwrapping을 하지 않아도 되고, 항상 값이 존재한다는 것을 표현할 수도 있다는 것 등등의 다양한 이점이 있지만,
개인적으로는 사용하지 않는 것이 좋다고 생각한다.&lt;/p&gt;

&lt;p&gt;관계를 표현하다가 실수를 할 수도 있고, 요구사항이 바뀌어 수정을 할 때 놓치는 부분이 될 수도 있다.
이런 저런 버그가 생겨 날 가능성이 더 크다고 생각한다.
그런 것들을 감수하면서까지 굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 쓸 필요는 없다고 생각한다.
(정말 필요하다는 타당한 이유가 없다면 🙅‍♂️)&lt;/p&gt;

&lt;p&gt;단순하고 안전하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;unowned&lt;/code&gt; 참조를 지양하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조를 사용하도록 하자.&lt;br /&gt;
개인적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 참조에 &lt;code class=&quot;highlighter-rouge&quot;&gt;guard&lt;/code&gt; 구문을 사용하면, 왜 이렇게 마음이 편안한지 모르겠다. 😇&lt;/p&gt;</content><author><name>jamesujeon</name></author><category term="ios" /><category term="swift" /><summary type="html">TL;DR</summary></entry></feed>